<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="UM Bioinformatics Core" />


<title>Intro to Snakemake</title>

<script src="site_libs/header-attrs-2.26/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link rel="shortcut icon" href="favicon-16x16.png" />
<!--
Favicon from
https://twemoji.twitter.com/
https://favicon.io/emoji-favicons/repeat-button
-->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="shortcut icon" href="favicon-16x16.png" />
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Reproducible Computing</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="Module00_Introduction.html">Intro</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Working with Data
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Module01_storage_best_practices_UMRCP.html">Storage best practices</a>
    </li>
    <li>
      <a href="Module02_transferring_data_globus.html">Transferring data with Globus</a>
    </li>
    <li>
      <a href="Module03a_sneak_peek_great_lakes.html">Intro to Great Lakes</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Using the GreatLakes HPC
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Module03b_great_lakes_cluster.html">GreatLakes: sbatch and lmod</a>
    </li>
    <li>
      <a href="Module04_software_management_conda.html">Software management with Conda</a>
    </li>
    <li>
      <a href="Module05_containers_docker_singularity.html">Containerization with Docker/Singularity</a>
    </li>
    <li>
      <a href="exercise-2.html">Independent Exercise</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Workflow automation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Module06-intro-to-workflow-automation.html">Intro to workflow automation</a>
    </li>
    <li>
      <a href="Module-07-intro-to-snakemake.html">Intro to Snakemake</a>
    </li>
  </ul>
</li>
<li>
  <a href="Module99_Wrap_up.html">Wrap up</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Intro to Snakemake</h1>
<h4 class="author">UM Bioinformatics Core</h4>

</div>


<style type="text/css">
body{ /* Normal  */
      font-size: 14pt;
  }
pre {
  font-size: 12pt
}

.wrapper { overflow-x: auto; }
.wrapper table { white-space: nowrap; }

</style>
<p>By the end of this module, we will: * List the some advantages of a
robust workflow automation solution like Snakemake. * Describe the
fundamental relationship between Snakemake, a Snakefile, and the file
system. * Describe key parts of a Snakemake rule. * Build a Snakefile
and use Snakemake to automate a simple workflow. * Use wildcards to
easily extend a workflow to new inputs. * Show a Snakemake dry-run and
other ways to visualize the workflow.</p>
<div id="what-is-snakemake" class="section level2">
<h2>What is Snakemake?</h2>
<p>Snakemake is a python program that interprets a text file describing
your workflow against the file system and uses rules in that workflow to
transform inputs into outputs as necessary. Snakemake is essentially
<strong>declarative</strong> meaning that you don’t tell it what to do,
you simply ask for the final output and Snakemake figures out what it
needs to do. That declarative pattern supports several key
attributes:</p>
<ul>
<li>Snakemake workflows can gracefully extend to new inputs.</li>
<li>Snakemake is modular.</li>
<li>Snakemake is portable.</li>
<li>Snakemake is “durable” (i.e it crashes with poise).</li>
<li>Snakemake is efficient.</li>
</ul>
</div>
<div id="build-a-snakefile" class="section level2">
<h2>Build a Snakefile</h2>
<p>A Snakefile is a text file that decribes your workflow. It is
interpreted by the <code>snakemake</code> command. Building a good
Snakefile is the key step in understanding Snakemake, so we’ll begin
there.</p>
<div id="consider-a-sample-bash-script" class="section level3">
<h3>Consider a sample bash script</h3>
<p>To build a Snakefile it’s helpful to use a concrete example and also
helpful to adapt an existing script. The script below considers the 1868
novel “Little Women”, by Louisa May Alcott. It outputs a file containing
the ranked name counts for each of the four March sisters: Amy, Beth,
Jo, and Laurie. (It also emits a few intermediate files).</p>
<table class="fig">
<tr>
<th class="fig">
alcott_script/alcott_script.sh
</th>
</tr>
<tr>
<td class="fig">
<pre>
#!/bin/bash
# Which of the March sisters is referred to most often in
# part 1 of the Little Women?

# Split lines into words
cat inputs/little_women_part_1.txt \
    | tr -cs '[:alpha:]' '\n' \
    > 1.split_words.txt

# Count words
sort 1.split_words.txt | uniq -c \
    > 2.count_words.txt

# Sort words by descending count and add header
sort -k1,1nr 2.count_words.txt \
    | awk 'BEGIN {print "word\tcount"} { print $2 "\t" $1}' \
    > 3.sort_counts.txt

# Select names with respective counts
egrep '^(Jo|Amy|Laurie|Beth)\s' 3.sort_counts.txt > 4.select_words.txt
</pre>
</td>
<td class="fig">
TODO bash DAG
</td>
</tr>
</table>
<p><br/></p>
<p>It’s not necessary to understand the command in detail, but it is
helpful to consider the steps with their various outputs:</p>
<table class="fig">
<tr>
<th class="fig">
Inputs, steps, and outputs
</th>
</tr>
<tr>
<td class="fig">
inputs/little_women_part_1.txt
</td>
</tr>
<tr>
<td class="fig">
<pre>
CHAPTER ONE

PLAYING PILGRIMS

"Christmas won't be Christmas without any presents," grumbled Jo, lying
on the rug.

"It's so dreadful to be poor!" sighed Meg, looking down at her old
dress.
...
</pre>
</td>
</tr>
<tr>
<td class="fig">
1.split_words.txt
</td>
</tr>
<tr>
<td class="fig">
<pre>CHAPTER
ONE
PLAYING
PILGRIMS
Christmas
won
t
be
Christmas
without
</pre>
</td>
</tr>
<tr>
<td class="fig">
2.count_words.txt
</td>
</tr>
<tr>
<td class="fig">
<pre>
   1992 a
     75 A
      1 aback
      1 abase
      3 abashed
      1 abed
      1 abject
      3 able
      3 abominable
      1 abominably
</pre>
</td>
</tr>
<tr>
<td class="fig">
3.sort_counts.txt
</td>
</tr>
<tr>
<td class="fig">
<pre>
word    count
and 3811
the 3303
to  2303
a   1992
I   1988
her 1660
of  1490
in  1094
you 1010
</pre>
</td>
</tr>
<tr>
<td class="fig">
4.select_words.txt
</td>
</tr>
<tr>
<td class="fig">
<pre>
Jo  737
Laurie  319
Beth    294
Amy 283
</pre>
</td>
</tr>
</table>
<p><br/></p>
<p>To view the results interactively, you can execute the script.</p>
<pre class="sh"><code>export WORKSHOP_HOME=&quot;/nfs/turbo/umms-bioinf-wkshp/workshop/home/${USER}&quot;
cd $WORKSHOP_HOME/project_alcott/alcott_script

./alcott_script.sh</code></pre>
<p>And view excepts of the results in <code>less</code>. (Hit
<code>q</code> key to exit <code>less</code>.)</p>
<pre class="sh"><code>head inputs/little_women_part_1.txt *.txt | less</code></pre>
</div>
<div id="snakemake-and-the-snakefile" class="section level3">
<h3>Snakemake and the Snakefile</h3>
<p>Switch to the alcott_snakemake dir; note there are inputs and a
Snakefile</p>
<pre class="sh"><code>cd $WORKSHOP_HOME/project_alcott/alcott_snakemake
tree</code></pre>
<blockquote>
<pre><code>.
├── inputs
│   ├── little_women_part_1.txt
│   └── little_women_part_2.txt
└── workflow
└── Snakefile</code></pre>
</blockquote>
<p>A Snakefile is a simple markdown file.By convention, the snakefile is
named <code>Snakefile</code> and lives in the <code>workflow</code>
sub-directory. The current Snakefile is simply a stub based on the
earlier bash script:</p>
<table class="fig">
<tr>
<th class="fig">
workflow/Snakefile
</th>
</tr>
<tr>
<td class="fig">
<pre>
# split_lines ###########################################################
#cat inputs/little_women_part_1.txt \
#    | tr -cs '[:alpha:]' '\n' \
#    > 1.split_words.txt
# count_words ###########################################################
#sort 1.split_words.txt | uniq -c \
#    > 2.count_words.txt
## sort_count ###########################################################
#sort -k1,1nr 2.count_words.txt \
#    | awk 'BEGIN {print "word\tcount"} { print $2 "\t" $1}' \
#    > 3.sort_counts.txt
# select_words ##########################################################
#egrep '^(Jo|Amy|Laurie|Beth)\s' 3.sort_counts.txt > 4.select_words.txt
</pre>
</td>
</tr>
</table>
<p>A snakefile is composed of rules; each rule has a name and specifies
directives such as</p>
<ul>
<li>input (what the rule requires)</li>
<li>output (what the rule promises to generate)</li>
<li>shell (how it will make input into output)</li>
</ul>
<p>We add the first step in the workflow as a new rule. (Adding below
the existing comment block.) Note that we will keep the input files and
result files in separate directories.</p>
<pre><code>rule split_words:
    input: &quot;inputs/little_women_part_1.txt&quot;
    output: &quot;results/little_women_part_1.split_words.txt&quot; 
    shell: &quot;cat inputs/little_women_part_1.txt | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; results/little_women_part_1.split_words.txt&quot;</code></pre>
</div>
<div id="running-snakemake" class="section level3">
<h3>Running Snakemake</h3>
<ul>
<li>The <strong>snakemake</strong> python program interprets the
Snakefile and executes rules as appropriate to produce the expected
output.</li>
<li>The snakemake program is installed as a module on Great Lakes.</li>
<li>When launching snakemake, You specify the number of cores
(i.e. CPUs) with the -c flag. We will use 1 core.</li>
</ul>
<pre class="sh"><code>module load snakemake
module list
# confirm you are in the right working directory
tree</code></pre>
<blockquote>
<pre class="sh="><code>Currently Loaded Modules:
1) python3.10-anaconda/2023.03   2) snakemake/7.32.4
$ tree
.
├── inputs
│   ├── little_women_part_1.txt
│   └── little_women_part_2.txt
└── workflow
└── Snakefile</code></pre>
</blockquote>
<p>Run <code>snakemake</code> command as below. Note:</p>
<ul>
<li><code>snakemake</code> will look for a Snakefile in the workflow
directory.</li>
<li><code>snakemake</code> emits a log to the screen that include
<ul>
<li>run details</li>
<li>Job stats</li>
<li>Rule details</li>
<li>Completion status i.e. (100%) done</li>
</ul></li>
</ul>
<pre><code>snakemake -c1</code></pre>
<blockquote>
<pre><code>Building DAG of jobs...
Using shell: /usr/bin/bash
Provided cores: 1 (use --cores to define parallelism)
Rules claiming more threads will be scaled down.
Job stats:
job            count
-----------  -------
split_words        1
total              1
.
Select jobs to execute...
.
[Mon Jun 10 18:35:41 2024]
rule split_words:
input: inputs/little_women_part_1.txt
output: results/little_women_part_1.split_words.txt
jobid: 0
reason: Missing output files: results/little_women_part_1.split_words.txt
resources: tmpdir=/tmp
.
[Mon Jun 10 18:35:41 2024]
Finished job 0.
1 of 1 steps (100%) done
Complete log: .snakemake/log/2024-06-10T183541.204636.snakemake.log</code></pre>
</blockquote>
<p>Check the file system. Note new results/ dir and new file. Note that
<code>snakemake</code> created the results/ dir automatically.</p>
<pre class="sh"><code>tree</code></pre>
<blockquote>
<pre><code>.
├── inputs
│   ├── little_women_part_1.txt
│   └── little_women_part_2.txt
├── results
│   └── little_women_part_1.split_words.txt
└── workflow
└── Snakefile</code></pre>
</blockquote>
<p>Also note that <code>snakemake</code> creates a hidden directory
<code>.snakemake/</code> in the working directory. This holds various
info that help snakemake manage the workflow. It’s extremely rare for
you to need to examine the contents of the <code>.snakemake/</code>
directory, but FYI.</p>
<p>If you re-run <code>snakemake</code> it determines the filesystem is
up to date and no rules need to be triggered.</p>
<pre class="sh"><code>snakemake -c1</code></pre>
<blockquote>
<pre><code>Building DAG of jobs...
Nothing to be done (all requested files are present and up to date).
Complete log: .snakemake/log/2024-06-10T184850.944535.snakemake.log</code></pre>
</blockquote>
</div>
<div id="add-a-new-rule" class="section level3">
<h3>Add a new rule</h3>
<p>In the Snakemake file, add the second step as a new rule below the
first rule. Note that the inputs of this rule match the outputs of the
prior rule.</p>
<pre><code>rule count_words:
    input: &quot;results/little_women_part_1.split_words.txt&quot;
    output: &quot;results/little_women_part_1.count_words.txt&quot;
    shell: &quot;sort results/little_women_part_1.split_words.txt | uniq -c &gt; results/little_women_part_1.count_words.txt&quot;</code></pre>
<p>By default, <code>snakemake</code> only runs the first rule in the
Snakefile. To trigger the new rule, you can specify the desired end
target on the command line.</p>
<pre class="sh"><code>snakemake -c1 count_words</code></pre>
<p>Note the log output similar to above, but now shows the new rule.</p>
<blockquote>
<pre><code>Building DAG of jobs...
Using shell: /usr/bin/bash
Provided cores: 1 (use --cores to define parallelism)
Rules claiming more threads will be scaled down.
Job stats:
job            count
-----------  -------
count_words        1
total              1
.
Select jobs to execute...
.
[Mon Jun 10 18:52:07 2024]
rule count_words:
input: results/little_women_part_1.split_words.txt
output: results/little_women_part_1.count_words.txt
jobid: 0
reason: Missing output files: results/little_women_part_1.count_words.txt
resources: tmpdir=/tmp
.
[Mon Jun 10 18:52:08 2024]
Finished job 0.
1 of 1 steps (100%) done
Complete log: .snakemake/log/2024-06-10T185207.598695.snakemake.log</code></pre>
</blockquote>
<p>See the new file and review the contents:</p>
<pre class="sh"><code>head results/*</code></pre>
<blockquote>
<pre><code>==&gt; results/little_women_part1.count_words.txt &lt;==
1992 a
75 A
1 aback
1 abase
3 abashed
1 abed
1 abject
3 able
3 abominable
1 abominably
.
==&gt; results/little_women_part_1.split_words.txt &lt;==
CHAPTER
ONE
PLAYING
PILGRIMS
Christmas
won
t
be
Christmas
without</code></pre>
</blockquote>
</div>
<div id="variables-rule-ordering" class="section level3">
<h3>Variables / Rule ordering</h3>
<p>Each rule defines <strong>input</strong> and <strong>output</strong>
variables; you can use those values in the <strong>shell</strong>
directive:</p>
<pre><code>rule split_words:
    input: &quot;inputs/little_women_part_1.txt&quot;
    output: &quot;results/little_women_part_1.split_words.txt&quot;
    shell: &quot;cat {input} | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; {output}&quot;

rule count_words:
    input: &quot;results/little_women_part_1.split_words.txt&quot;
    output: &quot;results/little_women_part1.count_words.txt&quot;
    shell: &quot;sort {input} | uniq -c &gt; {output}&quot;</code></pre>
<p>Snakemake doesn’t care what order the rules appear in the Snakefile
but it assumes the first rule is the default target. Put the last step
of the workflow at the top of the file and <code>snakemake</code> will
default to running the whole workflow.</p>
<pre><code>rule count_words:
    input: &quot;results/little_women_part_1.split_words.txt&quot;
    output: &quot;results/little_women_part1.count_words.txt&quot;
    shell: &quot;sort {input} | uniq -c &gt; {output}&quot;

rule split_words:
    input: &quot;inputs/little_women_part_1.txt&quot;
    output: &quot;results/little_women_part_1.split_words.txt&quot;
    shell: &quot;cat {input} | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; {output}&quot;</code></pre>
<p>Rerun after making these changes, and check out the log (excepted
below).</p>
<ul>
<li>Note that in <strong>Job stats</strong> all rules are
triggered.</li>
<li>Note the value of reason in each of the rules. Does the reason make
sense?</li>
</ul>
<pre class="sh"><code>snakemake -c1</code></pre>
<blockquote>
<pre><code>...
Job stats:
job            count
-----------  -------
count_words        1
split_words        1
total              2
...
rule split_words:
input: inputs/little_women_part_1.txt
output: results/little_women_part_1.split_words.txt
jobid: 1
reason: Code has changed since last execution
resources: tmpdir=/tmp
...
rule count_words:
input: results/little_women_part_1.split_words.txt
output: results/little_women_part1.count_words.txt
jobid: 0
reason: Input files updated by another job: results/little_women_part_1.split_words.txt
resources: tmpdir=/tmp</code></pre>
</blockquote>
</div>
<div id="using-triple-quotes-escaping-curly-braces"
class="section level3">
<h3>Using triple quotes / Escaping curly braces</h3>
<p>Add the third step of the transform</p>
<ul>
<li>Place it <strong>above</strong> the existing rules.</li>
<li>Use {input} and {output} variables.</li>
<li>We use triple quotes to make multiline shell commands.</li>
<li>In the shell, any braces ({}) related to the command must be doubled
to distinguish them from Snakefile variables.</li>
</ul>
<pre><code>rule sort_counts:
    input: &quot;results/little_women_part_1.count_words.txt&quot;
    output: &quot;results/little_women_part_1.sort_counts.txt&quot;
    shell: &quot;&quot;&quot;
    sort -k1,1nr {input} \
        | awk &#39;BEGIN {{print &quot;word\tcount&quot;}} {{ print $2 &quot;\t&quot; $1}}&#39; \
            &gt; {output}
        &quot;&quot;&quot;</code></pre>
<p>Note that when you run <code>snakemake</code> it only generates the
files it needs to.</p>
<pre class="sh"><code>snakemake -c1</code></pre>
<blockquote>
<pre><code>...
Job stats:
job            count
-----------  -------
sort_counts        1
total              1
...
rule sort_counts:
input: results/little_women_part_1.count_words.txt
output: results/little_women_part_1.sort_counts.txt
jobid: 0
reason: Missing output files: results/little_women_part_1.sort_counts.txt
resources: tmpdir=/tmp
...
1 of 1 steps (100%) done</code></pre>
<p>Use triple quotes to create multiline shell commands. If your
commands use curly braces ({}) you need to double them so snakemake
doesn’t get confused.</p>
</blockquote>
</div>
<div id="snakemake-dry-run-interpreting-rule-errors"
class="section level3">
<h3>Snakemake dry-run / Interpreting rule errors</h3>
<p>Add the fourth rule, placing it above the prior.</p>
<pre><code>rule select_words:
    input: &quot;results/little_women_part_1.sort_counts.txt&quot;
    output: &quot;results/little_women_part_1.select_words.txt&quot;
    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;</code></pre>
<p>You probably have noticed that <code>snakemake</code> will only run
the rules it needs to, based on changes in files or scripts or missing
files. You can preview what <code>snakemake</code> will do by using the
dry-run flag <code>--dry-run</code> or <code>-n</code>. This will show
the typical snakemake output but will not change any files.</p>
<pre class="sh"><code>snakemake -c1 --dry-run</code></pre>
<blockquote>
<pre><code>Building DAG of jobs...
Job stats:
job             count
------------  -------
select_words        1
total               1
.
[Mon Jun 10 19:41:43 2024]
rule select_words:
input: results/little_women_part_1.sort_counts.txt
output: results/little_women_part_1.select_words.txt
jobid: 0
reason: Missing output files: results/little_women_part_1.select_words.txt
resources: tmpdir=/tmp
.
Job stats:
job             count
------------  -------
select_words        1
total               1
.
Reasons:
(check individual jobs above for details)
missing output files:
select_words
.
This was a dry-run (flag -n). The order of jobs does not reflect the order of execution.</code></pre>
</blockquote>
<p>Developing a Snakefile typically involves some troubleshooting along
the way. I’ve intentionally introduced a typo in the Snakefile and then
did a dry-run to show an Snakefile error message:</p>
<blockquote>
<pre><code>$ snakemake -c1 --dry-run
.
A  Building DAG of jobs...
B  MissingInputException in rule select_words in file .../Snakefile, line 15:
C  Missing input files for rule select_words:
D    output: results/little_women_part_1.select_words.txt
E    affected files:
F        result/little_women_part_1.sort_counts.txt</code></pre>
</blockquote>
<p>Note:</p>
<ul>
<li>B line number</li>
<li>C Misisng input files for rule select_words</li>
<li>E &amp; F result/little_women_part_1.sort_counts.txt</li>
</ul>
<p>Can you see the error? You will likely need to consider the rule in
context:</p>
<pre><code>rule select_words:
    input: &quot;result/little_women_part_1.sort_counts.txt&quot;
    output: &quot;results/little_women_part_1.select_words.txt&quot;
    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;

rule sort_counts:
    input: &quot;results/little_women_part_1.count_words.txt&quot;
    output: &quot;results/little_women_part_1.sort_counts.txt&quot;
    shell: &quot;&quot;&quot;
    sort -k1,1nr {input} \
        | awk &#39;BEGIN {{print &quot;word\tcount&quot;}} {{ print $2 &quot;\t&quot; $1}}&#39; \
            &gt; {output}
        &quot;&quot;&quot;
rule count_words:
    input: &quot;results/little_women_part_1.split_words.txt&quot;
    output: &quot;results/little_women_part_1.count_words.txt&quot;
    shell: &quot;sort {input} | uniq -c &gt; {output}&quot;

rule split_words:
    input: &quot;inputs/little_women_part_1.txt&quot;
    output: &quot;results/little_women_part_1.split_words.txt&quot;
    shell: &quot;cat {input} | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; {output}&quot;</code></pre>
<p>Fix the typo and confirm the fix using <code>--dry-run</code> to get
a clean output. Then execute <code>snakemake</code> normally until you
are 100% done.</p>
</div>
<div id="visualizing-the-dag-rulegraph" class="section level3">
<h3>Visualizing the DAG / rulegraph</h3>
<p>In addition to doing a dry run, <code>snakemake</code> can generate a
diagram of the rules to execute. Snakemake thinks of the rules as a <a
href="https://en.wikipedia.org/wiki/Directed_acyclic_graph"
target="_blank">Directed Acyclic Graph</a> (DAG). You can see this with
the <code>--dag</code> flag and the <code>dot</code> program (part of <a
href="https://graphviz.org/" target="_blank">Graphviz</a>, an open
source graph visualizer).</p>
<pre class="sh"><code>snakemake --dag | dot -Tpng &gt; dag.png</code></pre>
<p><img src="images/Module07_dag.png" alt="dag.png" /> <br/></p>
<p>As you can see above, by default <code>dot</code> displays the graphs
vertically with inputs at the top and outputs at the bottom. Our
Snakefile is arranged from output to input, so you can invert the
diagram like so:</p>
<pre class="sh"><code>snakemake --dag | dot -Grankdir=&quot;BT&quot; -Tpng &gt; dag_inverted.png</code></pre>
<p><img src="images/Module07_dag_inverted.png" alt="dag_inverted.png" />
<br/></p>
</div>
<div id="all-target-wildcards-visualizaing-the-rulegraph"
class="section level3">
<h3>All target / Wildcards / Visualizaing the rulegraph</h3>
<p>To emphasize the endpoint of the workflow and also clarify the
default target, it’s common to place a “rule all” at the top of the
file. (This also allows you to reorder rules within the file
arbitrarily.) It is unusual in that it only has an input directive.</p>
<pre><code>rule all:
    input: &quot;results/little_women_part_1.select_words.txt&quot;</code></pre>
<p>Snakemake <em>wildcards</em> make it easy to to extend the workflow
to new inputs. (And they typically reduce repetition of file names.)
Here is an excerpt of the Snakefile showing the original
<strong>select_words</strong> rule and the same rule with wildcards.</p>
<pre><code>rule all:
    input: &quot;results/little_women_part_1.select_words.txt&quot;

# original rule
# rule select_words:
#    input: &quot;result/little_women_part_1.sort_counts.txt&quot;
#    output: &quot;results/little_women_part_1.select_words.txt&quot;
#    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;

# now with wildcards
rule select_words:
    input: &quot;result/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;
</code></pre>
<p>How does this work?</p>
<ul>
<li>The <strong>all</strong> rule needs an input named
“results/little_women_part_1.select_words.txt”</li>
<li>The <strong>select_words</strong> rule can produce
“results/{base_name}.select_words.txt” which would match the
<strong>all</strong> input if the wildcard
<em>{base_name}</em>=“little_women_part_1”</li>
<li>In <strong>select_word</strong> input, the rule substitutes the
<em>{base_name}</em> value for it’s wildcard, making
“result/little_women_part_1.sort_counts.txt”</li>
<li>So the the value of the wildcard is determined by the file name in
the all rule and that value propigates from output to input.</li>
</ul>
<p>What happens if we run snakemake?</p>
<pre class="sh"><code>snakemake -c1 --dry-run</code></pre>
<blockquote>
<pre><code>Building DAG of jobs...
Nothing to be done (all requested files are present and up to date).</code></pre>
</blockquote>
<p>And that actually makes sense: even though we used wildcards, the
rules ended up with identical input and output values.</p>
<p>We can extend wildcards across remaining rules as below. Note that we
need to keep the literal value in the <strong>all</strong> rule so the
other rules can derive the value of the wildcard.</p>
<pre><code>rule all:
    input: &quot;results/little_women_part_1.select_words.txt&quot;

rule select_words:
    input: &quot;results/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;

rule sort_counts:
    input: &quot;results/{base_name}.count_words.txt&quot;
    output: &quot;results/{base_name}.sort_counts.txt&quot;
    shell: &quot;&quot;&quot;
    sort -k1,1nr {input} \
        | awk &#39;BEGIN {{print &quot;word\tcount&quot;}} {{ print $2 &quot;\t&quot; $1}}&#39; \
            &gt; {output}
        &quot;&quot;&quot;
rule count_words:
    input: &quot;results/{base_name}.split_words.txt&quot;
    output: &quot;results/{base_name}.count_words.txt&quot;
    shell: &quot;sort {input} | uniq -c &gt; {output}&quot;

rule split_words:
    input: &quot;inputs/{base_name}.txt&quot;
    output: &quot;results/{base_name}.split_words.txt&quot;
    shell: &quot;cat {input} | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; {output}&quot;</code></pre>
<p>Now that the Snakefile is using wildcards, it is trivial to extend it
to new inputs. We adjust the <strong>all</strong> rule adding a second
value, separated by a comma:</p>
<pre><code>rule all:
    input: &quot;results/little_women_part_1.select_words.txt&quot;, &quot;results/little_women_part_2.select_words.txt&quot;
...</code></pre>
<p>The addition of a new wildcard value (little_women_part_2) will
trigger all five rules.</p>
<pre class="sh"><code>snakemake --dry-run</code></pre>
<blockquote>
<pre><code>...
Job stats:
job             count
------------  -------
all                 1
count_words         1
select_words        1
sort_counts         1
split_words         1
total               5
...</code></pre>
</blockquote>
<p>Before we run this for real, let’s add a new flag
<code>--forceall</code> to tell snakemake to trigger every single rule
for all possible inputs. Basically act like there are no existing
outputs and it needs to start from scratch. But this is still a dry-run,
so no files will be changed.</p>
<pre class="sh"><code>snakemake --dry-run --forceall</code></pre>
<blockquote>
<pre><code>...
Job stats:
job             count
------------  -------
all                 1
count_words         2
select_words        2
sort_counts         2
split_words         2
total               9
...</code></pre>
</blockquote>
<p>Try generating a DAG visualization. (Now it’s truly looking more like
a graph.) Note:</p>
<ul>
<li>Each wildcard value gets it’s own path</li>
<li>The wildcard values are displayed at the input</li>
<li>Some box outlines are solid and other are dotted; why is that?</li>
</ul>
<pre class="sh"><code>snakemake --dag | dot -Grankdir=&quot;BT&quot; -Tpng &gt; dag_inverted_wildcards.png</code></pre>
<p><img src="images/Module07_dag_inverted_wildcards.png"
alt="dag_inverted_wildcards.png" /> <br/></p>
<p>With complex workflows, you sometimes don’t want to see all the
possible inputs and would rather just see the abstract relationship of
the rules. Snakemake supports this with a related flag
<code>--rulegraph</code></p>
<pre class="sh"><code>snakemake --rulegraph | dot -Grankdir=&quot;BT&quot; -Tpng &gt; rulegraph.png</code></pre>
<p><img src="images/Module07_rulegraph.png" alt="rulegraph.png" />
<br/></p>
<p>Ok. Go ahead and run <code>snakemake</code> until you are 100%
complete and see these files in results:</p>
<blockquote>
<pre><code>$ ls results
little_women_part_1.count_words.txt   little_women_part_2.count_words.txt
little_women_part_1.select_words.txt  little_women_part_2.select_words.txt
little_women_part_1.sort_counts.txt   little_women_part_2.sort_counts.txt
little_women_part_1.split_words.txt   little_women_part_2.split_words.txt</code></pre>
</blockquote>
</div>
<div id="the-expand-function-config-files-parameters"
class="section level3">
<h3>The expand function / config files / parameters</h3>
<p>Ideally, a workflow could be run on a new set of inputs without
changing the Snakefile at all. For example, given the text of
Shakespeare’s <a href="https://www.gutenberg.org/ebooks/1513">Romeo and
Juliet</a> we could see whether Montague is mentioned more than Capulet.
Most of the rules in the workflow are already general enough to work
with two exceptions:</p>
<ul>
<li>The <strong>all</strong> rule mentions specific texts.</li>
<li>The <strong>select_words</strong> rule mentions specific names.</li>
</ul>
<p>We can extract these specifics from the Snakefile using a companion
configuration file. We’ll start with the <strong>select_words</strong>
rule.</p>
<pre><code>rule select_words:
    input: &quot;results/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    shell: &quot;egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; {input} &gt; {output}&quot;</code></pre>
<p>Firstly, we’ll pull the regular expression out of the shell directive
into a <a
href="https://snakemake.readthedocs.io/en/stable/snakefiles/configuration.html#configuration"
target="_blank">configuration file</a>. Snakemake supports several
styles of configuration file; we’ll use the YAML syntax. By convention
we’ll create config/config.yaml; you could create and edit this file
manually; alternatively you can also execute the line below:</p>
<pre class="sh"><code>mkdir config
echo &#39;select_words_regex: ^(Jo|Amy|Laurie|Beth)\s&#39; &gt; config/config.yaml
cat config/config.yaml</code></pre>
<p>Now add this line above the <strong>all</strong>:</p>
<pre><code>configfile: &quot;config/config.yaml&quot;</code></pre>
<p>Add a parameter initialized to the config key
<em>select_words_regex</em>. Then adjust the select_words rule to
refernce that parameter.</p>
<pre><code>rule select_words:
    input: &quot;results/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    params: regex=config[select_words_regex]
    shell: &quot;egrep &#39;{params.regex}&#39; {input} &gt; {output}&quot;</code></pre>
<p>The <a
href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#non-file-parameters-for-rules"
target="_blank">params directive</a> is a way of adjusting the shell
command with a value that isn’t tied to the filesystem. Also note that
params can be named (e.g. <code>x="value"</code>) and referenced by name
in the shell (<code>{params.x}</code>).</p>
<p>Now that we’ve made this change, let’s dry-run snakemake. Note we’re
adding the <code>-p</code> flag so snakemake will print out the actual
commands it will execute:</p>
<pre class="sh"><code>snakemake --dry-run -p</code></pre>
<p>In the output, note:</p>
<ul>
<li>In Job stats, we see snakemake believes we need to rerun
<strong>select_words</strong> for both inputs.</li>
<li>In the rule details, the reason the rule is triggered is that code
and params have changed</li>
<li>Because we used <code>-p</code>, you can see the actual egrep
statement (which looks fine).</li>
</ul>
<blockquote>
<pre><code>Building DAG of jobs...
Job stats:
job             count
------------  -------
all                 1
select_words        2
total               3
.
[Mon Jun 10 23:01:21 2024]
rule select_words:
input: results/little_women_part_1.sort_counts.txt
output: results/little_women_part_1.select_words.txt
jobid: 1
reason: Code has changed since last execution; Params have changed since last execution
wildcards: base_name=little_women_part_1
resources: tmpdir=/tmp
.
egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; results/little_women_part_1.sort_counts.txt &gt; results/little_women_part_1.select_words.txt
.
[Mon Jun 10 23:01:21 2024]
rule select_words:
input: results/little_women_part_2.sort_counts.txt
output: results/little_women_part_2.select_words.txt
jobid: 5
reason: Code has changed since last execution; Params have changed since last execution
wildcards: base_name=little_women_part_2
resources: tmpdir=/tmp
.
egrep &#39;^(Jo|Amy|Laurie|Beth)\s&#39; results/little_women_part_2.sort_counts.txt &gt; results/little_women_part_2.select_words.txt
...</code></pre>
</blockquote>
<p>Go ahead and run snakemake until 100% done.</p>
<p>Now we’ll pull the file base names from the <strong>all</strong> rule
into the config file:</p>
<pre><code>select_words_regex: ^(Jo|Amy|Laurie|Beth)\s

input_base_filenames:
  - little_women_part_1
  - little_women_part_2</code></pre>
<p>To get these values from config.yaml into the <strong>all</strong>
rule, I need to introduce the <code>expand</code> function. <a
href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#the-expand-function"
target="_blank">expand</a> is a helper function that comes with
Snakemake. It’s easier to explain if we show a few examples of inputs
and outputs:</p>
<blockquote>
<pre><code>expand(&quot;{dataset}/a.txt&quot;, dataset=[1, 2])
[&#39;1/a.txt&#39;, &#39;2/a.txt&#39;, &#39;3/a.txt&#39;]
.
expand(&quot;{a}.{b}&quot;, a=[&#39;fig1&#39;, &#39;fig2&#39;, &#39;fig3&#39;], b=[&#39;png&#39;, &#39;pdf&#39;])
[&#39;fig1.png&#39;, &#39;fig1.pdf&#39;, &#39;fig2.png&#39;, &#39;fig2.pdf&#39;, &#39;fig3.png&#39;, &#39;fig3.pdf&#39;]
.
expand(&quot;results/{x}.select_words.txt&quot;, \
...         x=[&quot;little_women_part_1&quot;, &quot;little_women_part_2&quot;])
[&#39;results/little_women_part_1.select_words.txt&#39;, &#39;results/little_women_part_2.select_words.txt&#39;]</code></pre>
</blockquote>
<p><code>expand</code> accepts a string pattern with named placeholders
(e.g. {dataset}) and named lists (e.g. dataset=[1, 2]); it builds a list
of strings by inserting the list values into the pattern.</p>
<p>That last example above is exactly what we need in the
<strong>all</strong> rule. The final step is to adapt the example above
to use the config file, like so:</p>
<pre><code>rule all:
    input: expand(&quot;results/{x}.select_words.txt&quot;, \
        x=config[&#39;input_base_filenames&#39;])</code></pre>
<p>The Snakefile is now free of any references to specific inputs. The
workflow can be run on a different set of inputs by using a new
config.yaml.</p>
<pre><code>configfile: &quot;config/config.yaml&quot;

rule all:
    input: expand(&quot;results/{x}.select_words.txt&quot;, \
    x=config[&#39;input_base_filenames&#39;])


rule select_words:
    input: &quot;results/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    params: regex=config[&quot;select_words_regex&quot;]
    shell: &quot;egrep &#39;{params.regex}&#39; {input} &gt; {output}&quot;

rule sort_counts:
    input: &quot;results/{base_name}.count_words.txt&quot;
    output: &quot;results/{base_name}.sort_counts.txt&quot;
    shell: &quot;&quot;&quot;
    sort -k1,1nr {input} \
        | awk &#39;BEGIN {{print &quot;word\tcount&quot;}} {{ print $2 &quot;\t&quot; $1}}&#39; \
            &gt; {output}
        &quot;&quot;&quot;
rule count_words:
    input: &quot;results/{base_name}.split_words.txt&quot;
    output: &quot;results/{base_name}.count_words.txt&quot;
    shell: &quot;sort {input} | uniq -c &gt; {output}&quot;

rule split_words:
    input: &quot;inputs/{base_name}.txt&quot;
    output: &quot;results/{base_name}.split_words.txt&quot;
    shell: &quot;cat {input} | tr -cs &#39;[:alpha:]&#39; &#39;\n&#39; &gt; {output}&quot;
</code></pre>
<hr />
</div>
<div id="snakemake-on-great-lakes" class="section level3">
<h3>Snakemake on Great Lakes</h3>
<p>All this time we’ve been executing the workflow on the login-nodes.
It’s generally fine to execute the <code>snakemake</code> process itself
on the login-node, but for a more demanding workflow you should execute
the rules on Great Lakes worker nodes.</p>
<p>It’s straightforward to do this by using a profile. A profile is
essentially just a little config file that tells <code>snakemake</code>
how it should submit rules as jobs. Check out snakemake docs for details
on <a
href="https://snakemake.readthedocs.io/en/stable/executing/cli.html#profiles"
target="_blank">profile</a> options. We’ll start with a simple profile
built for Great Lakes:</p>
<pre class="sh"><code>cp -r /nfs/turbo/umms-bioinf-wkshp/workshop/shared-data/profile/ config/</code></pre>
<div class="wrapper">
<table class="fig">
<tr>
<th class="fig">
config/profile/config.yaml
</th>
</tr>
<tr>
<td class="fig">
<pre>
printshellcmds: True
keep-going: True
use-singularity: True
singularity-args: "--cleanenv -B $(pwd)"
cluster: sbatch --job-name=alcott_{rule}_{wildcards} --account=bioinf_wkshp_class --partition=standard --nodes=1 --cpus-per-task={resources.cpus} --mem={resources.mem_mb} --time={resources.time_min} --output=cluster_logs/%x-%j.log --parsable
default-resources: [cpus=1, mem_mb=2000, time_min=120]
rerun-triggers: [mtime]
latency-wait: 300
jobs: 5
</pre>
</td>
</tr>
</table>
</div>
<p>Invoking <code>snakemake</code> with this profile submits each rule a
an sbatch job:</p>
<pre class="sh"><code># clear out existing files so there&#39;s something to do
rm results/*

snakemake --profile config/profile</code></pre>
<p>Note that you can adjust the SLURM job geometry by adding a
<em>resources</em> directive to a rule. These values will be
incorporated into the sbatch request for this rule.</p>
<pre><code>rule select_words:
    input: &quot;results/{base_name}.sort_counts.txt&quot;
    output: &quot;results/{base_name}.select_words.txt&quot;
    resources: cpus=4, mem_mb=4000, time_min=5  
    params: regex=config[&quot;select_words_regex&quot;]
    shell: &quot;egrep &#39;{params.regex}&#39; {input} &gt; {output}&quot;</code></pre>
</div>
<div id="using-tmux" class="section level3">
<h3>Using tmux</h3>
<p><a href="https://en.wikipedia.org/wiki/Tmux">tmux</a> is a unix
utility that let’s you create virtual screens inside of a single
session. (It’s like the Unix utility <em>screen</em>, but more powerful
and current.) For our purposes, the killer feature of tmux is captured
in this simple vignette:</p>
<ul>
<li>login to great lakes and start a tmux session on the login-node:
<code>tmux</code></li>
<li>start a long running task (e.g. a snakemake workflow which submits
to the cluster)</li>
<li>detach from that tmux session: hit <code>ctrl-b</code>
<code>d</code></li>
<li>turn off your computer, go home, and login to great lakes from
different computer</li>
<li>reattach to that tmux session: <code>tmux attach</code></li>
<li>you will see your long-running task has been running all along,
completely unaffected by your wanderings</li>
</ul>
<p>And in fact, tmux can actually do much, much more. Here’s a nifty <a
href="https://opensource.com/sites/default/files/gated-content/osdc_cheatsheet-tmux-2021.6.25.pdf"
target="_blank">cheatsheet</a>.</p>
<hr />
</div>
</div>
<div id="pro-tips" class="section level2">
<h2>Pro tips</h2>
<ol style="list-style-type: decimal">
<li>Start learning Snakemake with a simple workflow. Don’t start with a
really complex workflow.</li>
<li>It’s ok to build your Snakefile from the first steps toward the
last, but remember that Snakemake “thinks” from the last output
backward.</li>
<li>Keep your inputs, outputs, and workflow in separate
directories.</li>
<li>Build your Snakefile incrementally.
<ol style="list-style-type: lower-alpha">
<li>Start with a single input.</li>
<li>Add a rule at a time.</li>
<li>Make small changes and use <code>dry-run</code> liberally.</li>
<li>OK to start by hardcoding filenames; put the wildcards in
afterward.</li>
</ol></li>
<li>Keep consistent naming conventions. Including your rule names in
your file names will help you troubleshoot. Some people include numbers
in the file names or place different outputs in different directories.
Choose a pattern that works for you and be consistent.</li>
<li>If you subset your input data so that your steps are fast and light,
you can prototype the Snakefile on the login-nodes. (But be ready to hit
control-C if you wander into a computationally intensive step.)</li>
<li>Use spaces not tabs.</li>
<li>Use config files to avoid hardcoding paths or “magic values” in the
Snakefile.</li>
</ol>
<hr />
</div>
<div id="key-ideas" class="section level2">
<h2>Key ideas</h2>
<ul>
<li>A robust workflow automation solution is great because:
<ul>
<li>it supports simple (e.g. linear) and complex (e.g. graph)
transformations equally well</li>
<li>only outstanding steps are run and individual steps are atomic</li>
<li>it’s designed with software dependency management in mind</li>
<li>it’s easy to tune, resulting in higher resource efficiency</li>
<li>it’s portable across execution environments</li>
<li>it’s designed to gracefully scale to many inputs</li>
<li>all the capabilities above don’t obscure the actual data
transfromation</li>
</ul></li>
<li>Snakemake is a Python program that evaluates the rules in a
Snakefile against the file system and applies rules as necessary to
produce the desired output files.</li>
<li>The Snakefile is a simple markdown file composed of rules. Each rule
contains <strong>directives</strong> that specify inputs, outputs,
commands to run foe that rule.</li>
<li>Snakemake builds the intended set of rules into a <strong>directed
acyclic graph</strong> (DAG).</li>
<li>The <strong>dry-run</strong> enables you to see the rules it will
execute in advance.</li>
<li>You can visualize the Snakemake DAG or rulegraph using
<code>dot</code>.</li>
<li>Command line flags we reviewed:
<ul>
<li>-c</li>
<li>-n –dry-run</li>
<li>–dag –rulegraph</li>
<li>–forceall</li>
<li>-p –printshellcmds</li>
</ul></li>
</ul>
<p>References and links: - <a
href="https://snakemake.readthedocs.io/en/stable/index.html"
class="uri">https://snakemake.readthedocs.io/en/stable/index.html</a> -
<a
href="https://snakemake.readthedocs.io/en/stable/executing/cli.html#all-options"
class="uri">https://snakemake.readthedocs.io/en/stable/executing/cli.html#all-options</a>
- <a
href="https://snakemake.readthedocs.io/en/stable/snakefiles/writing_snakefiles.html#grammar"
class="uri">https://snakemake.readthedocs.io/en/stable/snakefiles/writing_snakefiles.html#grammar</a></p>
<p>Exercise 1A: cd to the project publication_snakemake_1 Given this DAG
can you fill in the missing parts of this Snakefile?</p>
<p>Exercise 1B: Use params and a config file to extract hardcoded inputs
and “magic values”.</p>
<hr />
<table style="width:100%;">
<colgroup>
<col width="28%" />
<col width="42%" />
<col width="28%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><a
href="Module06-intro-to-workflow-automation.html">Previous
lesson</a></th>
<th align="center"><a href="#top">Top of this lesson</a></th>
<th align="right"><a href="Module99_Wrap_up.html">Wrap up</a></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiSW50cm8gdG8gU25ha2VtYWtlIgphdXRob3I6ICJVTSBCaW9pbmZvcm1hdGljcyBDb3JlIgpvdXRwdXQ6CiAgICAgICAgaHRtbF9kb2N1bWVudDoKICAgICAgICAgICAgaW5jbHVkZXM6CiAgICAgICAgICAgICAgICBpbl9oZWFkZXI6IGhlYWRlci5odG1sCiAgICAgICAgICAgIHRoZW1lOiBwYXBlcgogICAgICAgICAgICB0b2M6IHRydWUKICAgICAgICAgICAgdG9jX2RlcHRoOiA0CiAgICAgICAgICAgIHRvY19mbG9hdDogdHJ1ZQogICAgICAgICAgICBudW1iZXJfc2VjdGlvbnM6IGZhbHNlCiAgICAgICAgICAgIGZpZ19jYXB0aW9uOiB0cnVlCiAgICAgICAgICAgIG1hcmtkb3duOiBHRk0KICAgICAgICAgICAgY29kZV9kb3dubG9hZDogdHJ1ZQotLS0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KYm9keXsgLyogTm9ybWFsICAqLwogICAgICBmb250LXNpemU6IDE0cHQ7CiAgfQpwcmUgewogIGZvbnQtc2l6ZTogMTJwdAp9Cgoud3JhcHBlciB7IG92ZXJmbG93LXg6IGF1dG87IH0KLndyYXBwZXIgdGFibGUgeyB3aGl0ZS1zcGFjZTogbm93cmFwOyB9Cgo8L3N0eWxlPgoKQnkgdGhlIGVuZCBvZiB0aGlzIG1vZHVsZSwgd2Ugd2lsbDoKKiBMaXN0IHRoZSBzb21lIGFkdmFudGFnZXMgb2YgYSByb2J1c3Qgd29ya2Zsb3cgYXV0b21hdGlvbiBzb2x1dGlvbiBsaWtlIFNuYWtlbWFrZS4KKiBEZXNjcmliZSB0aGUgZnVuZGFtZW50YWwgcmVsYXRpb25zaGlwIGJldHdlZW4gU25ha2VtYWtlLCBhIFNuYWtlZmlsZSwgYW5kIHRoZSBmaWxlIHN5c3RlbS4KKiBEZXNjcmliZSBrZXkgcGFydHMgb2YgYSBTbmFrZW1ha2UgcnVsZS4KKiBCdWlsZCBhIFNuYWtlZmlsZSBhbmQgdXNlIFNuYWtlbWFrZSB0byBhdXRvbWF0ZSBhIHNpbXBsZSB3b3JrZmxvdy4KKiBVc2Ugd2lsZGNhcmRzIHRvIGVhc2lseSBleHRlbmQgYSB3b3JrZmxvdyB0byBuZXcgaW5wdXRzLgoqIFNob3cgYSBTbmFrZW1ha2UgZHJ5LXJ1biBhbmQgb3RoZXIgd2F5cyB0byB2aXN1YWxpemUgdGhlIHdvcmtmbG93LgoKCiMjIFdoYXQgaXMgU25ha2VtYWtlPwoKU25ha2VtYWtlIGlzIGEgcHl0aG9uIHByb2dyYW0gdGhhdCBpbnRlcnByZXRzIGEgdGV4dCBmaWxlIGRlc2NyaWJpbmcgeW91cgp3b3JrZmxvdyBhZ2FpbnN0IHRoZSBmaWxlIHN5c3RlbSBhbmQgdXNlcyBydWxlcyBpbiB0aGF0IHdvcmtmbG93IHRvIHRyYW5zZm9ybQppbnB1dHMgaW50byBvdXRwdXRzIGFzIG5lY2Vzc2FyeS4gU25ha2VtYWtlIGlzIGVzc2VudGlhbGx5ICoqZGVjbGFyYXRpdmUqKgptZWFuaW5nIHRoYXQgeW91IGRvbid0IHRlbGwgaXQgd2hhdCB0byBkbywgeW91IHNpbXBseSBhc2sgZm9yIHRoZSBmaW5hbCBvdXRwdXQKYW5kIFNuYWtlbWFrZSBmaWd1cmVzIG91dCB3aGF0IGl0IG5lZWRzIHRvIGRvLiBUaGF0IGRlY2xhcmF0aXZlIHBhdHRlcm4gc3VwcG9ydHMKc2V2ZXJhbCBrZXkgYXR0cmlidXRlczoKCi0gU25ha2VtYWtlIHdvcmtmbG93cyBjYW4gZ3JhY2VmdWxseSBleHRlbmQgdG8gbmV3IGlucHV0cy4KLSBTbmFrZW1ha2UgaXMgbW9kdWxhci4KLSBTbmFrZW1ha2UgaXMgcG9ydGFibGUuCi0gU25ha2VtYWtlIGlzIOKAnGR1cmFibGXigJ0gKGkuZSBpdCBjcmFzaGVzIHdpdGggcG9pc2UpLgotIFNuYWtlbWFrZSBpcyBlZmZpY2llbnQuCgoKIyMgQnVpbGQgYSBTbmFrZWZpbGUKCkEgU25ha2VmaWxlIGlzIGEgdGV4dCBmaWxlIHRoYXQgZGVjcmliZXMgeW91ciB3b3JrZmxvdy4gSXQgaXMgaW50ZXJwcmV0ZWQgYnkgdGhlCmBzbmFrZW1ha2VgIGNvbW1hbmQuIEJ1aWxkaW5nIGEgZ29vZCBTbmFrZWZpbGUgaXMgdGhlIGtleSBzdGVwIGluIHVuZGVyc3RhbmRpbmcKU25ha2VtYWtlLCBzbyB3ZSdsbCBiZWdpbiB0aGVyZS4KCiMjIyBDb25zaWRlciBhIHNhbXBsZSBiYXNoIHNjcmlwdAoKVG8gYnVpbGQgYSBTbmFrZWZpbGUgaXQncyBoZWxwZnVsIHRvIHVzZSBhIGNvbmNyZXRlIGV4YW1wbGUgYW5kIGFsc28gaGVscGZ1bCB0bwphZGFwdCBhbiBleGlzdGluZyBzY3JpcHQuIFRoZSBzY3JpcHQgYmVsb3cgY29uc2lkZXJzIHRoZSAxODY4IG5vdmVsICJMaXR0bGUKV29tZW4iLCBieSBMb3Vpc2EgTWF5IEFsY290dC4gSXQgb3V0cHV0cyBhIGZpbGUgY29udGFpbmluZyB0aGUgcmFua2VkIG5hbWUKY291bnRzIGZvciBlYWNoIG9mIHRoZSBmb3VyIE1hcmNoIHNpc3RlcnM6IEFteSwgQmV0aCwgSm8sIGFuZCBMYXVyaWUuIChJdAphbHNvIGVtaXRzIGEgZmV3IGludGVybWVkaWF0ZSBmaWxlcykuCgoKPHRhYmxlIGNsYXNzPSdmaWcnPjx0cj48dGggY2xhc3M9J2ZpZyc+YWxjb3R0X3NjcmlwdC9hbGNvdHRfc2NyaXB0LnNoPC90aD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+CiMhL2Jpbi9iYXNoCiMgV2hpY2ggb2YgdGhlIE1hcmNoIHNpc3RlcnMgaXMgcmVmZXJyZWQgdG8gbW9zdCBvZnRlbiBpbgojIHBhcnQgMSBvZiB0aGUgTGl0dGxlIFdvbWVuPwoKIyBTcGxpdCBsaW5lcyBpbnRvIHdvcmRzCmNhdCBpbnB1dHMvbGl0dGxlX3dvbWVuX3BhcnRfMS50eHQgXAogICAgfCB0ciAtY3MgJ1s6YWxwaGE6XScgJ1xuJyBcCiAgICA+IDEuc3BsaXRfd29yZHMudHh0CgojIENvdW50IHdvcmRzCnNvcnQgMS5zcGxpdF93b3Jkcy50eHQgfCB1bmlxIC1jIFwKICAgID4gMi5jb3VudF93b3Jkcy50eHQKCiMgU29ydCB3b3JkcyBieSBkZXNjZW5kaW5nIGNvdW50IGFuZCBhZGQgaGVhZGVyCnNvcnQgLWsxLDFuciAyLmNvdW50X3dvcmRzLnR4dCBcCiAgICB8IGF3ayAnQkVHSU4ge3ByaW50ICJ3b3JkXHRjb3VudCJ9IHsgcHJpbnQgJDIgIlx0IiAkMX0nIFwKICAgID4gMy5zb3J0X2NvdW50cy50eHQKCiMgU2VsZWN0IG5hbWVzIHdpdGggcmVzcGVjdGl2ZSBjb3VudHMKZWdyZXAgJ14oSm98QW15fExhdXJpZXxCZXRoKVxzJyAzLnNvcnRfY291bnRzLnR4dCA+IDQuc2VsZWN0X3dvcmRzLnR4dAo8L3ByZT48L3RkPgo8dGQgY2xhc3M9J2ZpZyc+VE9ETyBiYXNoIERBRzwvdGQ+CjwvdHI+PC90YWJsZT4KPGJyLz4KCgpJdCdzIG5vdCBuZWNlc3NhcnkgdG8gdW5kZXJzdGFuZCB0aGUgY29tbWFuZCBpbiBkZXRhaWwsIGJ1dCBpdCBpcyBoZWxwZnVsIHRvIApjb25zaWRlciB0aGUgc3RlcHMgd2l0aCB0aGVpciB2YXJpb3VzIG91dHB1dHM6CgoKPHRhYmxlIGNsYXNzPSdmaWcnPjx0cj48dGggY2xhc3M9J2ZpZyc+SW5wdXRzLCBzdGVwcywgYW5kIG91dHB1dHM8L3RoPjwvdHI+Cjx0cj48dGQgY2xhc3M9J2ZpZyc+aW5wdXRzL2xpdHRsZV93b21lbl9wYXJ0XzEudHh0PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+CkNIQVBURVIgT05FCgpQTEFZSU5HIFBJTEdSSU1TCgoiQ2hyaXN0bWFzIHdvbid0IGJlIENocmlzdG1hcyB3aXRob3V0IGFueSBwcmVzZW50cywiIGdydW1ibGVkIEpvLCBseWluZwpvbiB0aGUgcnVnLgoKIkl0J3Mgc28gZHJlYWRmdWwgdG8gYmUgcG9vciEiIHNpZ2hlZCBNZWcsIGxvb2tpbmcgZG93biBhdCBoZXIgb2xkCmRyZXNzLgouLi4KPC9wcmU+PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjEuc3BsaXRfd29yZHMudHh0PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+Q0hBUFRFUgpPTkUKUExBWUlORwpQSUxHUklNUwpDaHJpc3RtYXMKd29uCnQKYmUKQ2hyaXN0bWFzCndpdGhvdXQKPC9wcmU+PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjIuY291bnRfd29yZHMudHh0PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+CiAgIDE5OTIgYQogICAgIDc1IEEKICAgICAgMSBhYmFjawogICAgICAxIGFiYXNlCiAgICAgIDMgYWJhc2hlZAogICAgICAxIGFiZWQKICAgICAgMSBhYmplY3QKICAgICAgMyBhYmxlCiAgICAgIDMgYWJvbWluYWJsZQogICAgICAxIGFib21pbmFibHkKPC9wcmU+PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjMuc29ydF9jb3VudHMudHh0PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+CndvcmQJY291bnQKYW5kCTM4MTEKdGhlCTMzMDMKdG8JMjMwMwphCTE5OTIKSQkxOTg4CmhlcgkxNjYwCm9mCTE0OTAKaW4JMTA5NAp5b3UJMTAxMAo8L3ByZT48L3RkPjwvdHI+Cjx0cj48dGQgY2xhc3M9J2ZpZyc+NC5zZWxlY3Rfd29yZHMudHh0PC90ZD48L3RyPgo8dHI+PHRkIGNsYXNzPSdmaWcnPjxwcmU+CkpvCTczNwpMYXVyaWUJMzE5CkJldGgJMjk0CkFteQkyODMKPC9wcmU+PC90ZD48L3RyPgo8L3RhYmxlPgo8YnIvPgoKClRvIHZpZXcgdGhlIHJlc3VsdHMgaW50ZXJhY3RpdmVseSwgeW91IGNhbiBleGVjdXRlIHRoZSBzY3JpcHQuCgpgYGBzaApleHBvcnQgV09SS1NIT1BfSE9NRT0iL25mcy90dXJiby91bW1zLWJpb2luZi13a3NocC93b3Jrc2hvcC9ob21lLyR7VVNFUn0iCmNkICRXT1JLU0hPUF9IT01FL3Byb2plY3RfYWxjb3R0L2FsY290dF9zY3JpcHQKCi4vYWxjb3R0X3NjcmlwdC5zaApgYGAKCkFuZCB2aWV3IGV4Y2VwdHMgb2YgdGhlIHJlc3VsdHMgaW4gYGxlc3NgLiAoSGl0IGBxYCBrZXkgdG8gZXhpdCBgbGVzc2AuKQoKYGBgc2gKaGVhZCBpbnB1dHMvbGl0dGxlX3dvbWVuX3BhcnRfMS50eHQgKi50eHQgfCBsZXNzCmBgYAoKIyMjIFNuYWtlbWFrZSBhbmQgdGhlIFNuYWtlZmlsZQoKU3dpdGNoIHRvIHRoZSBhbGNvdHRfc25ha2VtYWtlIGRpcjsgbm90ZSB0aGVyZSBhcmUgaW5wdXRzIGFuZCBhIFNuYWtlZmlsZQpgYGBzaApjZCAkV09SS1NIT1BfSE9NRS9wcm9qZWN0X2FsY290dC9hbGNvdHRfc25ha2VtYWtlCnRyZWUKYGBgCj4gYGBgCi4K4pSc4pSA4pSAIGlucHV0cwrilILCoMKgIOKUnOKUgOKUgCBsaXR0bGVfd29tZW5fcGFydF8xLnR4dArilILCoMKgIOKUlOKUgOKUgCBsaXR0bGVfd29tZW5fcGFydF8yLnR4dArilJTilIDilIAgd29ya2Zsb3cKICAgIOKUlOKUgOKUgCBTbmFrZWZpbGUKICBgYGAKCgpBIFNuYWtlZmlsZSBpcyBhIHNpbXBsZSBtYXJrZG93biBmaWxlLkJ5IGNvbnZlbnRpb24sIHRoZQpzbmFrZWZpbGUgaXMgbmFtZWQgYFNuYWtlZmlsZWAgYW5kIGxpdmVzIGluIHRoZSBgd29ya2Zsb3dgIHN1Yi1kaXJlY3RvcnkuIApUaGUgY3VycmVudCBTbmFrZWZpbGUgaXMgc2ltcGx5IGEgc3R1YiBiYXNlZCBvbiB0aGUgZWFybGllciBiYXNoIHNjcmlwdDoKCjx0YWJsZSBjbGFzcz0nZmlnJz48dHI+PHRoIGNsYXNzPSdmaWcnPndvcmtmbG93L1NuYWtlZmlsZTwvdGg+PC90cj4KPHRyPjx0ZCBjbGFzcz0nZmlnJz48cHJlPgojIHNwbGl0X2xpbmVzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiNjYXQgaW5wdXRzL2xpdHRsZV93b21lbl9wYXJ0XzEudHh0IFwKIyAgICB8IHRyIC1jcyAnWzphbHBoYTpdJyAnXG4nIFwKIyAgICA+IDEuc3BsaXRfd29yZHMudHh0CiMgY291bnRfd29yZHMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKI3NvcnQgMS5zcGxpdF93b3Jkcy50eHQgfCB1bmlxIC1jIFwKIyAgICA+IDIuY291bnRfd29yZHMudHh0CiMjIHNvcnRfY291bnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKI3NvcnQgLWsxLDFuciAyLmNvdW50X3dvcmRzLnR4dCBcCiMgICAgfCBhd2sgJ0JFR0lOIHtwcmludCAid29yZFx0Y291bnQifSB7IHByaW50ICQyICJcdCIgJDF9JyBcCiMgICAgPiAzLnNvcnRfY291bnRzLnR4dAojIHNlbGVjdF93b3JkcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiNlZ3JlcCAnXihKb3xBbXl8TGF1cmllfEJldGgpXHMnIDMuc29ydF9jb3VudHMudHh0ID4gNC5zZWxlY3Rfd29yZHMudHh0CjwvcHJlPjwvdGQ+PC90cj48L3RhYmxlPgoKCkEgc25ha2VmaWxlIGlzIGNvbXBvc2VkIG9mIHJ1bGVzOyBlYWNoIHJ1bGUgaGFzIGEgbmFtZSBhbmQgc3BlY2lmaWVzIGRpcmVjdGl2ZXMgc3VjaCBhcwoKLSBpbnB1dCAod2hhdCB0aGUgcnVsZSByZXF1aXJlcykKLSBvdXRwdXQgKHdoYXQgdGhlIHJ1bGUgcHJvbWlzZXMgdG8gZ2VuZXJhdGUpCi0gc2hlbGwgKGhvdyBpdCB3aWxsIG1ha2UgaW5wdXQgaW50byBvdXRwdXQpCgpXZSBhZGQgdGhlIGZpcnN0IHN0ZXAgaW4gdGhlIHdvcmtmbG93IGFzIGEgbmV3IHJ1bGUuIChBZGRpbmcgYmVsb3cgdGhlIGV4aXN0aW5nCmNvbW1lbnQgYmxvY2suKSBOb3RlIHRoYXQgd2Ugd2lsbCBrZWVwIHRoZSBpbnB1dCBmaWxlcyBhbmQgcmVzdWx0IGZpbGVzIGluIApzZXBhcmF0ZSBkaXJlY3Rvcmllcy4KCmBgYApydWxlIHNwbGl0X3dvcmRzOgogICAgaW5wdXQ6ICJpbnB1dHMvbGl0dGxlX3dvbWVuX3BhcnRfMS50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0IiAKICAgIHNoZWxsOiAiY2F0IGlucHV0cy9saXR0bGVfd29tZW5fcGFydF8xLnR4dCB8IHRyIC1jcyAnWzphbHBoYTpdJyAnXG4nID4gcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNwbGl0X3dvcmRzLnR4dCIKYGBgCgojIyMgUnVubmluZyBTbmFrZW1ha2UKCi0gVGhlICoqc25ha2VtYWtlKiogcHl0aG9uIHByb2dyYW0gaW50ZXJwcmV0cyB0aGUgU25ha2VmaWxlIGFuZCBleGVjdXRlcyBydWxlcyBhcyAKYXBwcm9wcmlhdGUgdG8gcHJvZHVjZSB0aGUgZXhwZWN0ZWQgb3V0cHV0LiAKLSBUaGUgc25ha2VtYWtlIHByb2dyYW0gaXMgaW5zdGFsbGVkIGFzIGEgbW9kdWxlIG9uIEdyZWF0IExha2VzLgotIFdoZW4gbGF1bmNoaW5nIHNuYWtlbWFrZSwgWW91IHNwZWNpZnkgdGhlIG51bWJlciBvZiBjb3JlcyAoaS5lLiBDUFVzKSB3aXRoIHRoZQotYyBmbGFnLiBXZSB3aWxsIHVzZSAxIGNvcmUuCgpgYGBzaAptb2R1bGUgbG9hZCBzbmFrZW1ha2UKbW9kdWxlIGxpc3QKIyBjb25maXJtIHlvdSBhcmUgaW4gdGhlIHJpZ2h0IHdvcmtpbmcgZGlyZWN0b3J5CnRyZWUKYGBgCgo+IGBgYHNoPQpDdXJyZW50bHkgTG9hZGVkIE1vZHVsZXM6CiAgMSkgcHl0aG9uMy4xMC1hbmFjb25kYS8yMDIzLjAzICAgMikgc25ha2VtYWtlLzcuMzIuNAokIHRyZWUKLgrilJzilIDilIAgaW5wdXRzCuKUgsKgwqAg4pSc4pSA4pSAIGxpdHRsZV93b21lbl9wYXJ0XzEudHh0CuKUgsKgwqAg4pSU4pSA4pSAIGxpdHRsZV93b21lbl9wYXJ0XzIudHh0CuKUlOKUgOKUgCB3b3JrZmxvdwogICAg4pSU4pSA4pSAIFNuYWtlZmlsZQogIGBgYAoKClJ1biBgc25ha2VtYWtlYCBjb21tYW5kIGFzIGJlbG93LiBOb3RlOgoKLSBgc25ha2VtYWtlYCB3aWxsIGxvb2sgZm9yIGEgU25ha2VmaWxlIGluIHRoZSB3b3JrZmxvdyBkaXJlY3RvcnkuCi0gYHNuYWtlbWFrZWAgZW1pdHMgYSBsb2cgdG8gdGhlIHNjcmVlbiB0aGF0IGluY2x1ZGUgCiAgLSBydW4gZGV0YWlscwogIC0gSm9iIHN0YXRzCiAgLSBSdWxlIGRldGFpbHMKICAtIENvbXBsZXRpb24gc3RhdHVzIGkuZS4gKDEwMCUpIGRvbmUKCmBgYApzbmFrZW1ha2UgLWMxCmBgYAoKCj4gYGBgCiAgICBCdWlsZGluZyBEQUcgb2Ygam9icy4uLgogICAgVXNpbmcgc2hlbGw6IC91c3IvYmluL2Jhc2gKICAgIFByb3ZpZGVkIGNvcmVzOiAxICh1c2UgLS1jb3JlcyB0byBkZWZpbmUgcGFyYWxsZWxpc20pCiAgICBSdWxlcyBjbGFpbWluZyBtb3JlIHRocmVhZHMgd2lsbCBiZSBzY2FsZWQgZG93bi4KICAgIEpvYiBzdGF0czoKICAgIGpvYiAgICAgICAgICAgIGNvdW50CiAgICAtLS0tLS0tLS0tLSAgLS0tLS0tLQogICAgc3BsaXRfd29yZHMgICAgICAgIDEKICAgIHRvdGFsICAgICAgICAgICAgICAxCiAgICAuCiAgICBTZWxlY3Qgam9icyB0byBleGVjdXRlLi4uCiAgICAuCiAgICBbTW9uIEp1biAxMCAxODozNTo0MSAyMDI0XQogICAgcnVsZSBzcGxpdF93b3JkczoKICAgICAgICBpbnB1dDogaW5wdXRzL2xpdHRsZV93b21lbl9wYXJ0XzEudHh0CiAgICAgICAgb3V0cHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0CiAgICAgICAgam9iaWQ6IDAKICAgICAgICByZWFzb246IE1pc3Npbmcgb3V0cHV0IGZpbGVzOiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0CiAgICAgICAgcmVzb3VyY2VzOiB0bXBkaXI9L3RtcAogICAgLgogICAgW01vbiBKdW4gMTAgMTg6MzU6NDEgMjAyNF0KICAgIEZpbmlzaGVkIGpvYiAwLgogICAgMSBvZiAxIHN0ZXBzICgxMDAlKSBkb25lCiAgICBDb21wbGV0ZSBsb2c6IC5zbmFrZW1ha2UvbG9nLzIwMjQtMDYtMTBUMTgzNTQxLjIwNDYzNi5zbmFrZW1ha2UubG9nCiAgYGBgCgpDaGVjayB0aGUgZmlsZSBzeXN0ZW0uIE5vdGUgbmV3IHJlc3VsdHMvIGRpciBhbmQgbmV3IGZpbGUuIE5vdGUgdGhhdCBgc25ha2VtYWtlYApjcmVhdGVkIHRoZSByZXN1bHRzLyBkaXIgYXV0b21hdGljYWxseS4KCmBgYHNoCnRyZWUKYGBgCgo+IGBgYAouCuKUnOKUgOKUgCBpbnB1dHMK4pSCwqDCoCDilJzilIDilIAgbGl0dGxlX3dvbWVuX3BhcnRfMS50eHQK4pSCwqDCoCDilJTilIDilIAgbGl0dGxlX3dvbWVuX3BhcnRfMi50eHQK4pSc4pSA4pSAIHJlc3VsdHMK4pSCwqDCoCDilJTilIDilIAgbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQK4pSU4pSA4pSAIHdvcmtmbG93CiAgICDilJTilIDilIAgU25ha2VmaWxlCiAgYGBgCgpBbHNvIG5vdGUgdGhhdCBgc25ha2VtYWtlYCBjcmVhdGVzIGEgaGlkZGVuIGRpcmVjdG9yeSBgLnNuYWtlbWFrZS9gIGluIHRoZSB3b3JraW5nIApkaXJlY3RvcnkuIFRoaXMgaG9sZHMgdmFyaW91cyBpbmZvIHRoYXQgaGVscCBzbmFrZW1ha2UgbWFuYWdlIHRoZSB3b3JrZmxvdy4gSXQncwpleHRyZW1lbHkgcmFyZSBmb3IgeW91IHRvIG5lZWQgdG8gZXhhbWluZSB0aGUgY29udGVudHMgb2YgdGhlIGAuc25ha2VtYWtlL2AgCmRpcmVjdG9yeSwgYnV0IEZZSS4KCklmIHlvdSByZS1ydW4gYHNuYWtlbWFrZWAgaXQgZGV0ZXJtaW5lcyB0aGUgZmlsZXN5c3RlbSBpcyB1cCB0byBkYXRlIGFuZCBubyAKcnVsZXMgbmVlZCB0byBiZSB0cmlnZ2VyZWQuCgpgYGBzaApzbmFrZW1ha2UgLWMxCmBgYAoKPiBgYGAKQnVpbGRpbmcgREFHIG9mIGpvYnMuLi4KTm90aGluZyB0byBiZSBkb25lIChhbGwgcmVxdWVzdGVkIGZpbGVzIGFyZSBwcmVzZW50IGFuZCB1cCB0byBkYXRlKS4KQ29tcGxldGUgbG9nOiAuc25ha2VtYWtlL2xvZy8yMDI0LTA2LTEwVDE4NDg1MC45NDQ1MzUuc25ha2VtYWtlLmxvZwogIGBgYAoKCiMjIyBBZGQgYSBuZXcgcnVsZQoKSW4gdGhlIFNuYWtlbWFrZSBmaWxlLCBhZGQgdGhlIHNlY29uZCBzdGVwIGFzIGEgbmV3IHJ1bGUgYmVsb3cgdGhlIGZpcnN0IHJ1bGUuCk5vdGUgdGhhdCB0aGUgaW5wdXRzIG9mIHRoaXMgcnVsZSBtYXRjaCB0aGUgb3V0cHV0cyBvZiB0aGUgcHJpb3IgcnVsZS4KCmBgYApydWxlIGNvdW50X3dvcmRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0IgogICAgb3V0cHV0OiAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLmNvdW50X3dvcmRzLnR4dCIKICAgIHNoZWxsOiAic29ydCByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0IHwgdW5pcSAtYyA+IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5jb3VudF93b3Jkcy50eHQiCmBgYAoKQnkgZGVmYXVsdCwgYHNuYWtlbWFrZWAgb25seSBydW5zIHRoZSBmaXJzdCBydWxlIGluIHRoZSBTbmFrZWZpbGUuIFRvIHRyaWdnZXIgCnRoZSBuZXcgcnVsZSwgeW91IGNhbiBzcGVjaWZ5IHRoZSBkZXNpcmVkIGVuZCB0YXJnZXQgb24gdGhlIGNvbW1hbmQgbGluZS4KCmBgYHNoCnNuYWtlbWFrZSAtYzEgY291bnRfd29yZHMKYGBgCgpOb3RlIHRoZSBsb2cgb3V0cHV0IHNpbWlsYXIgdG8gYWJvdmUsIGJ1dCBub3cgc2hvd3MgdGhlIG5ldyBydWxlLgoKPiBgYGAKQnVpbGRpbmcgREFHIG9mIGpvYnMuLi4KVXNpbmcgc2hlbGw6IC91c3IvYmluL2Jhc2gKUHJvdmlkZWQgY29yZXM6IDEgKHVzZSAtLWNvcmVzIHRvIGRlZmluZSBwYXJhbGxlbGlzbSkKUnVsZXMgY2xhaW1pbmcgbW9yZSB0aHJlYWRzIHdpbGwgYmUgc2NhbGVkIGRvd24uCkpvYiBzdGF0czoKam9iICAgICAgICAgICAgY291bnQKLS0tLS0tLS0tLS0gIC0tLS0tLS0KY291bnRfd29yZHMgICAgICAgIDEKdG90YWwgICAgICAgICAgICAgIDEKLgpTZWxlY3Qgam9icyB0byBleGVjdXRlLi4uCi4KW01vbiBKdW4gMTAgMTg6NTI6MDcgMjAyNF0KcnVsZSBjb3VudF93b3JkczoKICAgIGlucHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0CiAgICBvdXRwdXQ6IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5jb3VudF93b3Jkcy50eHQKICAgIGpvYmlkOiAwCiAgICByZWFzb246IE1pc3Npbmcgb3V0cHV0IGZpbGVzOiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuY291bnRfd29yZHMudHh0CiAgICByZXNvdXJjZXM6IHRtcGRpcj0vdG1wCi4KW01vbiBKdW4gMTAgMTg6NTI6MDggMjAyNF0KRmluaXNoZWQgam9iIDAuCjEgb2YgMSBzdGVwcyAoMTAwJSkgZG9uZQpDb21wbGV0ZSBsb2c6IC5zbmFrZW1ha2UvbG9nLzIwMjQtMDYtMTBUMTg1MjA3LjU5ODY5NS5zbmFrZW1ha2UubG9nCiAgYGBgCgpTZWUgdGhlIG5ldyBmaWxlIGFuZCByZXZpZXcgdGhlIGNvbnRlbnRzOgoKYGBgc2gKaGVhZCByZXN1bHRzLyoKYGBgCgo+IGBgYAo9PT4gcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydDEuY291bnRfd29yZHMudHh0IDw9PQogICAxOTkyIGEKICAgICA3NSBBCiAgICAgIDEgYWJhY2sKICAgICAgMSBhYmFzZQogICAgICAzIGFiYXNoZWQKICAgICAgMSBhYmVkCiAgICAgIDEgYWJqZWN0CiAgICAgIDMgYWJsZQogICAgICAzIGFib21pbmFibGUKICAgICAgMSBhYm9taW5hYmx5Ci4KPT0+IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQgPD09CkNIQVBURVIKT05FClBMQVlJTkcKUElMR1JJTVMKQ2hyaXN0bWFzCndvbgp0CmJlCkNocmlzdG1hcwp3aXRob3V0CiAgYGBgCgojIyMgVmFyaWFibGVzIC8gUnVsZSBvcmRlcmluZwoKRWFjaCBydWxlIGRlZmluZXMgKippbnB1dCoqIGFuZCAqKm91dHB1dCoqIHZhcmlhYmxlczsgeW91IGNhbiB1c2UgdGhvc2UgdmFsdWVzCmluIHRoZSAqKnNoZWxsKiogZGlyZWN0aXZlOgoKYGBgCnJ1bGUgc3BsaXRfd29yZHM6CiAgICBpbnB1dDogImlucHV0cy9saXR0bGVfd29tZW5fcGFydF8xLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQiCiAgICBzaGVsbDogImNhdCB7aW5wdXR9IHwgdHIgLWNzICdbOmFscGhhOl0nICdcbicgPiB7b3V0cHV0fSIKCnJ1bGUgY291bnRfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0MS5jb3VudF93b3Jkcy50eHQiCiAgICBzaGVsbDogInNvcnQge2lucHV0fSB8IHVuaXEgLWMgPiB7b3V0cHV0fSIKYGBgCgpTbmFrZW1ha2UgZG9lc24ndCBjYXJlIHdoYXQgb3JkZXIgdGhlIHJ1bGVzIGFwcGVhciBpbiB0aGUgU25ha2VmaWxlIGJ1dCBpdCAKYXNzdW1lcyB0aGUgZmlyc3QgcnVsZSBpcyB0aGUgZGVmYXVsdCB0YXJnZXQuIFB1dCB0aGUgbGFzdCBzdGVwIG9mIHRoZSB3b3JrZmxvdyAKYXQgdGhlIHRvcCBvZiB0aGUgZmlsZSBhbmQgYHNuYWtlbWFrZWAgd2lsbCBkZWZhdWx0IHRvIHJ1bm5pbmcgdGhlIHdob2xlIHdvcmtmbG93LgoKYGBgCnJ1bGUgY291bnRfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0MS5jb3VudF93b3Jkcy50eHQiCiAgICBzaGVsbDogInNvcnQge2lucHV0fSB8IHVuaXEgLWMgPiB7b3V0cHV0fSIKCnJ1bGUgc3BsaXRfd29yZHM6CiAgICBpbnB1dDogImlucHV0cy9saXR0bGVfd29tZW5fcGFydF8xLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQiCiAgICBzaGVsbDogImNhdCB7aW5wdXR9IHwgdHIgLWNzICdbOmFscGhhOl0nICdcbicgPiB7b3V0cHV0fSIKYGBgCgpSZXJ1biBhZnRlciBtYWtpbmcgdGhlc2UgY2hhbmdlcywgYW5kIGNoZWNrIG91dCB0aGUgbG9nIChleGNlcHRlZCBiZWxvdykuCgogIC0gTm90ZSB0aGF0IGluICoqSm9iIHN0YXRzKiogYWxsIHJ1bGVzIGFyZSB0cmlnZ2VyZWQuCiAgLSBOb3RlIHRoZSB2YWx1ZSBvZiByZWFzb24gaW4gZWFjaCBvZiB0aGUgcnVsZXMuIERvZXMgdGhlIHJlYXNvbiBtYWtlIHNlbnNlPwoKYGBgc2gKc25ha2VtYWtlIC1jMQpgYGAKCj4gYGBgCi4uLgpKb2Igc3RhdHM6CmpvYiAgICAgICAgICAgIGNvdW50Ci0tLS0tLS0tLS0tICAtLS0tLS0tCmNvdW50X3dvcmRzICAgICAgICAxCnNwbGl0X3dvcmRzICAgICAgICAxCnRvdGFsICAgICAgICAgICAgICAyCi4uLgpydWxlIHNwbGl0X3dvcmRzOgogICAgaW5wdXQ6IGlucHV0cy9saXR0bGVfd29tZW5fcGFydF8xLnR4dAogICAgb3V0cHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0CiAgICBqb2JpZDogMQogICAgcmVhc29uOiBDb2RlIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgZXhlY3V0aW9uCiAgICByZXNvdXJjZXM6IHRtcGRpcj0vdG1wCi4uLgpydWxlIGNvdW50X3dvcmRzOgogICAgaW5wdXQ6IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQKICAgIG91dHB1dDogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydDEuY291bnRfd29yZHMudHh0CiAgICBqb2JpZDogMAogICAgcmVhc29uOiBJbnB1dCBmaWxlcyB1cGRhdGVkIGJ5IGFub3RoZXIgam9iOiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0CiAgICByZXNvdXJjZXM6IHRtcGRpcj0vdG1wCiAgYGBgCgoKIyMjIFVzaW5nIHRyaXBsZSBxdW90ZXMgLyBFc2NhcGluZyBjdXJseSBicmFjZXMKCkFkZCB0aGUgdGhpcmQgc3RlcCBvZiB0aGUgdHJhbnNmb3JtCgotIFBsYWNlIGl0ICoqYWJvdmUqKiB0aGUgZXhpc3RpbmcgcnVsZXMuCi0gVXNlIHtpbnB1dH0gYW5kIHtvdXRwdXR9IHZhcmlhYmxlcy4KLSBXZSB1c2UgdHJpcGxlIHF1b3RlcyB0byBtYWtlIG11bHRpbGluZSBzaGVsbCBjb21tYW5kcy4KLSBJbiB0aGUgc2hlbGwsIGFueSBicmFjZXMgKHt9KSByZWxhdGVkIHRvIHRoZSBjb21tYW5kIG11c3QgYmUgZG91YmxlZCB0byAKZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIFNuYWtlZmlsZSB2YXJpYWJsZXMuCgpgYGAKcnVsZSBzb3J0X2NvdW50czoKICAgIGlucHV0OiAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLmNvdW50X3dvcmRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zb3J0X2NvdW50cy50eHQiCiAgICBzaGVsbDogIiIiCglzb3J0IC1rMSwxbnIge2lucHV0fSBcCgkgICAgfCBhd2sgJ0JFR0lOIHt7cHJpbnQgIndvcmRcdGNvdW50In19IHt7IHByaW50ICQyICJcdCIgJDF9fScgXAogICAgICAgICAgICA+IHtvdXRwdXR9CiAgICAgICAgIiIiCmBgYAoKTm90ZSB0aGF0IHdoZW4geW91IHJ1biBgc25ha2VtYWtlYCBpdCBvbmx5IGdlbmVyYXRlcyB0aGUgZmlsZXMgaXQgbmVlZHMgdG8uCgpgYGBzaApzbmFrZW1ha2UgLWMxCmBgYAoKPiBgYGAKLi4uCkpvYiBzdGF0czoKam9iICAgICAgICAgICAgY291bnQKLS0tLS0tLS0tLS0gIC0tLS0tLS0Kc29ydF9jb3VudHMgICAgICAgIDEKdG90YWwgICAgICAgICAgICAgIDEKLi4uCnJ1bGUgc29ydF9jb3VudHM6CiAgICBpbnB1dDogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLmNvdW50X3dvcmRzLnR4dAogICAgb3V0cHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc29ydF9jb3VudHMudHh0CiAgICBqb2JpZDogMAogICAgcmVhc29uOiBNaXNzaW5nIG91dHB1dCBmaWxlczogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNvcnRfY291bnRzLnR4dAogICAgcmVzb3VyY2VzOiB0bXBkaXI9L3RtcAouLi4KMSBvZiAxIHN0ZXBzICgxMDAlKSBkb25lCiAgYGBgClVzZSB0cmlwbGUgcXVvdGVzIHRvIGNyZWF0ZSBtdWx0aWxpbmUgc2hlbGwgY29tbWFuZHMuIElmIHlvdXIgY29tbWFuZHMgdXNlIGN1cmx5IGJyYWNlcyAoe30pIHlvdSBuZWVkIHRvIGRvdWJsZSB0aGVtIHNvIHNuYWtlbWFrZSBkb2Vzbid0IGdldCBjb25mdXNlZC4KCiMjIyBTbmFrZW1ha2UgZHJ5LXJ1biAvIEludGVycHJldGluZyBydWxlIGVycm9ycwoKQWRkIHRoZSBmb3VydGggcnVsZSwgcGxhY2luZyBpdCBhYm92ZSB0aGUgcHJpb3IuCgpgYGAKcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zb3J0X2NvdW50cy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc2VsZWN0X3dvcmRzLnR4dCIKICAgIHNoZWxsOiAiZWdyZXAgJ14oSm98QW15fExhdXJpZXxCZXRoKVxzJyB7aW5wdXR9ID4ge291dHB1dH0iCmBgYAoKWW91IHByb2JhYmx5IGhhdmUgbm90aWNlZCB0aGF0IGBzbmFrZW1ha2VgIHdpbGwgb25seSBydW4gdGhlIHJ1bGVzIGl0IG5lZWRzIHRvLCAKYmFzZWQgb24gY2hhbmdlcyBpbiBmaWxlcyBvciBzY3JpcHRzIG9yIG1pc3NpbmcgZmlsZXMuIFlvdSBjYW4gcHJldmlldyB3aGF0IApgc25ha2VtYWtlYCB3aWxsIGRvIGJ5IHVzaW5nIHRoZSBkcnktcnVuIGZsYWcgYC0tZHJ5LXJ1bmAgb3IgYC1uYC4gVGhpcyB3aWxsCnNob3cgdGhlIHR5cGljYWwgc25ha2VtYWtlIG91dHB1dCBidXQgd2lsbCBub3QgY2hhbmdlIGFueSBmaWxlcy4KCmBgYHNoCnNuYWtlbWFrZSAtYzEgLS1kcnktcnVuCmBgYAoKPiBgYGAKQnVpbGRpbmcgREFHIG9mIGpvYnMuLi4KSm9iIHN0YXRzOgpqb2IgICAgICAgICAgICAgY291bnQKLS0tLS0tLS0tLS0tICAtLS0tLS0tCnNlbGVjdF93b3JkcyAgICAgICAgMQp0b3RhbCAgICAgICAgICAgICAgIDEKLgpbTW9uIEp1biAxMCAxOTo0MTo0MyAyMDI0XQpydWxlIHNlbGVjdF93b3JkczoKICAgIGlucHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc29ydF9jb3VudHMudHh0CiAgICBvdXRwdXQ6IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zZWxlY3Rfd29yZHMudHh0CiAgICBqb2JpZDogMAogICAgcmVhc29uOiBNaXNzaW5nIG91dHB1dCBmaWxlczogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQKICAgIHJlc291cmNlczogdG1wZGlyPS90bXAKLgpKb2Igc3RhdHM6CmpvYiAgICAgICAgICAgICBjb3VudAotLS0tLS0tLS0tLS0gIC0tLS0tLS0Kc2VsZWN0X3dvcmRzICAgICAgICAxCnRvdGFsICAgICAgICAgICAgICAgMQouClJlYXNvbnM6CiAgICAoY2hlY2sgaW5kaXZpZHVhbCBqb2JzIGFib3ZlIGZvciBkZXRhaWxzKQogICAgbWlzc2luZyBvdXRwdXQgZmlsZXM6CiAgICAgICAgc2VsZWN0X3dvcmRzCi4KVGhpcyB3YXMgYSBkcnktcnVuIChmbGFnIC1uKS4gVGhlIG9yZGVyIG9mIGpvYnMgZG9lcyBub3QgcmVmbGVjdCB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uLgogIGBgYAoKRGV2ZWxvcGluZyBhIFNuYWtlZmlsZSB0eXBpY2FsbHkgaW52b2x2ZXMgc29tZSB0cm91Ymxlc2hvb3RpbmcgYWxvbmcgdGhlIHdheS4KSSd2ZSBpbnRlbnRpb25hbGx5IGludHJvZHVjZWQgYSB0eXBvIGluIHRoZSBTbmFrZWZpbGUgYW5kIHRoZW4gZGlkIGEgZHJ5LXJ1biB0bwpzaG93IGFuIFNuYWtlZmlsZSBlcnJvciBtZXNzYWdlOgoKPiBgYGAKJCBzbmFrZW1ha2UgLWMxIC0tZHJ5LXJ1bgouCkEgIEJ1aWxkaW5nIERBRyBvZiBqb2JzLi4uCkIgIE1pc3NpbmdJbnB1dEV4Y2VwdGlvbiBpbiBydWxlIHNlbGVjdF93b3JkcyBpbiBmaWxlIC4uLi9TbmFrZWZpbGUsIGxpbmUgMTU6CkMgIE1pc3NpbmcgaW5wdXQgZmlsZXMgZm9yIHJ1bGUgc2VsZWN0X3dvcmRzOgpEICAgIG91dHB1dDogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQKRSAgICBhZmZlY3RlZCBmaWxlczoKRiAgICAgICAgcmVzdWx0L2xpdHRsZV93b21lbl9wYXJ0XzEuc29ydF9jb3VudHMudHh0CiAgYGBgCgpOb3RlOgoKLSBCIGxpbmUgbnVtYmVyIAotIEMgTWlzaXNuZyBpbnB1dCBmaWxlcyBmb3IgcnVsZSBzZWxlY3Rfd29yZHMKLSBFICYgRiByZXN1bHQvbGl0dGxlX3dvbWVuX3BhcnRfMS5zb3J0X2NvdW50cy50eHQKCkNhbiB5b3Ugc2VlIHRoZSBlcnJvcj8gWW91IHdpbGwgbGlrZWx5IG5lZWQgdG8gY29uc2lkZXIgdGhlIHJ1bGUgaW4gY29udGV4dDoKCmBgYApydWxlIHNlbGVjdF93b3JkczoKICAgIGlucHV0OiAicmVzdWx0L2xpdHRsZV93b21lbl9wYXJ0XzEuc29ydF9jb3VudHMudHh0IgogICAgb3V0cHV0OiAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQiCiAgICBzaGVsbDogImVncmVwICdeKEpvfEFteXxMYXVyaWV8QmV0aClccycge2lucHV0fSA+IHtvdXRwdXR9IgoKcnVsZSBzb3J0X2NvdW50czoKICAgIGlucHV0OiAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLmNvdW50X3dvcmRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zb3J0X2NvdW50cy50eHQiCiAgICBzaGVsbDogIiIiCglzb3J0IC1rMSwxbnIge2lucHV0fSBcCgkgICAgfCBhd2sgJ0JFR0lOIHt7cHJpbnQgIndvcmRcdGNvdW50In19IHt7IHByaW50ICQyICJcdCIgJDF9fScgXAogICAgICAgICAgICA+IHtvdXRwdXR9CiAgICAgICAgIiIiCnJ1bGUgY291bnRfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zcGxpdF93b3Jkcy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuY291bnRfd29yZHMudHh0IgogICAgc2hlbGw6ICJzb3J0IHtpbnB1dH0gfCB1bmlxIC1jID4ge291dHB1dH0iCgpydWxlIHNwbGl0X3dvcmRzOgogICAgaW5wdXQ6ICJpbnB1dHMvbGl0dGxlX3dvbWVuX3BhcnRfMS50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc3BsaXRfd29yZHMudHh0IgogICAgc2hlbGw6ICJjYXQge2lucHV0fSB8IHRyIC1jcyAnWzphbHBoYTpdJyAnXG4nID4ge291dHB1dH0iCmBgYAoKRml4IHRoZSB0eXBvIGFuZCBjb25maXJtIHRoZSBmaXggdXNpbmcgYC0tZHJ5LXJ1bmAgdG8gZ2V0IGEgY2xlYW4gb3V0cHV0LiBUaGVuCmV4ZWN1dGUgYHNuYWtlbWFrZWAgbm9ybWFsbHkgdW50aWwgeW91IGFyZSAxMDAlIGRvbmUuIAoKIyMjIFZpc3VhbGl6aW5nIHRoZSBEQUcgLyBydWxlZ3JhcGgKCkluIGFkZGl0aW9uIHRvIGRvaW5nIGEgZHJ5IHJ1biwgYHNuYWtlbWFrZWAgY2FuIGdlbmVyYXRlIGEgZGlhZ3JhbSBvZiB0aGUgcnVsZXMKdG8gZXhlY3V0ZS4gU25ha2VtYWtlIHRoaW5rcyBvZiB0aGUgcnVsZXMgYXMgYSBbRGlyZWN0ZWQgQWN5Y2xpYwpHcmFwaF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlyZWN0ZWRfYWN5Y2xpY19ncmFwaCl7dGFyZ2V0PSJfYmxhbmsifQooREFHKS4gWW91IGNhbiBzZWUgdGhpcyB3aXRoIHRoZSBgLS1kYWdgIGZsYWcgYW5kIHRoZSBgZG90YCBwcm9ncmFtIChwYXJ0IG9mCltHcmFwaHZpel0oaHR0cHM6Ly9ncmFwaHZpei5vcmcvKXt0YXJnZXQ9Il9ibGFuayJ9LCBhbiBvcGVuIHNvdXJjZSBncmFwaAp2aXN1YWxpemVyKS4KCmBgYHNoCnNuYWtlbWFrZSAtLWRhZyB8IGRvdCAtVHBuZyA+IGRhZy5wbmcKYGBgCgohW2RhZy5wbmddKGltYWdlcy9Nb2R1bGUwN19kYWcucG5nKQo8YnIvPgoKQXMgeW91IGNhbiBzZWUgYWJvdmUsIGJ5IGRlZmF1bHQgYGRvdGAgZGlzcGxheXMgdGhlIGdyYXBocyB2ZXJ0aWNhbGx5IHdpdGggaW5wdXRzCmF0IHRoZSB0b3AgYW5kICBvdXRwdXRzIGF0IHRoZSBib3R0b20uIE91ciBTbmFrZWZpbGUgaXMgYXJyYW5nZWQgZnJvbSAKb3V0cHV0IHRvIGlucHV0LCBzbyB5b3UgY2FuIGludmVydCB0aGUgZGlhZ3JhbSBsaWtlIHNvOgoKYGBgc2gKc25ha2VtYWtlIC0tZGFnIHwgZG90IC1HcmFua2Rpcj0iQlQiIC1UcG5nID4gZGFnX2ludmVydGVkLnBuZwpgYGAKCiFbZGFnX2ludmVydGVkLnBuZ10oaW1hZ2VzL01vZHVsZTA3X2RhZ19pbnZlcnRlZC5wbmcpCjxici8+CgojIyMgQWxsIHRhcmdldCAvIFdpbGRjYXJkcyAvIFZpc3VhbGl6YWluZyB0aGUgcnVsZWdyYXBoCgpUbyBlbXBoYXNpemUgdGhlIGVuZHBvaW50IG9mIHRoZSB3b3JrZmxvdyBhbmQgYWxzbyBjbGFyaWZ5IHRoZSBkZWZhdWx0IHRhcmdldCwKaXQncyBjb21tb24gdG8gcGxhY2UgYSAicnVsZSBhbGwiIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUuIChUaGlzIGFsc28gYWxsb3dzIHlvdQp0byByZW9yZGVyIHJ1bGVzIHdpdGhpbiB0aGUgZmlsZSBhcmJpdHJhcmlseS4pIEl0IGlzIHVudXN1YWwgaW4gdGhhdCBpdCBvbmx5IGhhcwphbiBpbnB1dCBkaXJlY3RpdmUuCgpgYGAKcnVsZSBhbGw6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zZWxlY3Rfd29yZHMudHh0IgpgYGAKClNuYWtlbWFrZSAqd2lsZGNhcmRzKiBtYWtlIGl0IGVhc3kgdG8gdG8gZXh0ZW5kIHRoZSB3b3JrZmxvdyB0byBuZXcgaW5wdXRzLiAoQW5kCnRoZXkgdHlwaWNhbGx5IHJlZHVjZSByZXBldGl0aW9uIG9mIGZpbGUgbmFtZXMuKSBIZXJlIGlzIGFuIGV4Y2VycHQgb2YgdGhlIApTbmFrZWZpbGUgc2hvd2luZyB0aGUgb3JpZ2luYWwgKipzZWxlY3Rfd29yZHMqKiBydWxlIGFuZCB0aGUgc2FtZSBydWxlIHdpdGggCndpbGRjYXJkcy4KCmBgYApydWxlIGFsbDoKICAgIGlucHV0OiAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQiCgojIG9yaWdpbmFsIHJ1bGUKIyBydWxlIHNlbGVjdF93b3JkczoKIyAgICBpbnB1dDogInJlc3VsdC9saXR0bGVfd29tZW5fcGFydF8xLnNvcnRfY291bnRzLnR4dCIKIyAgICBvdXRwdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc2VsZWN0X3dvcmRzLnR4dCIKIyAgICBzaGVsbDogImVncmVwICdeKEpvfEFteXxMYXVyaWV8QmV0aClccycge2lucHV0fSA+IHtvdXRwdXR9IgoKIyBub3cgd2l0aCB3aWxkY2FyZHMKcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdC97YmFzZV9uYW1lfS5zb3J0X2NvdW50cy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNlbGVjdF93b3Jkcy50eHQiCiAgICBzaGVsbDogImVncmVwICdeKEpvfEFteXxMYXVyaWV8QmV0aClccycge2lucHV0fSA+IHtvdXRwdXR9IgoKYGBgCkhvdyBkb2VzIHRoaXMgd29yaz8KCi0gVGhlICoqYWxsKiogcnVsZSBuZWVkcyBhbiBpbnB1dCBuYW1lZCAicmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQiCi0gVGhlICoqc2VsZWN0X3dvcmRzKiogcnVsZSBjYW4gcHJvZHVjZSAicmVzdWx0cy97YmFzZV9uYW1lfS5zZWxlY3Rfd29yZHMudHh0IiB3aGljaCB3b3VsZCBtYXRjaCB0aGUgKiphbGwqKiBpbnB1dCBpZiB0aGUgd2lsZGNhcmQgKntiYXNlX25hbWV9Kj0ibGl0dGxlX3dvbWVuX3BhcnRfMSIKLSBJbiAqKnNlbGVjdF93b3JkKiogaW5wdXQsIHRoZSBydWxlIHN1YnN0aXR1dGVzIHRoZSAqe2Jhc2VfbmFtZX0qIHZhbHVlIGZvciBpdCdzIHdpbGRjYXJkLCBtYWtpbmcgInJlc3VsdC9saXR0bGVfd29tZW5fcGFydF8xLnNvcnRfY291bnRzLnR4dCIKLSBTbyB0aGUgdGhlIHZhbHVlIG9mIHRoZSB3aWxkY2FyZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlIG5hbWUgaW4gdGhlIGFsbCBydWxlIGFuZCB0aGF0IHZhbHVlIHByb3BpZ2F0ZXMgZnJvbSBvdXRwdXQgdG8gaW5wdXQuCgpXaGF0IGhhcHBlbnMgaWYgd2UgcnVuIHNuYWtlbWFrZT8KCmBgYHNoCnNuYWtlbWFrZSAtYzEgLS1kcnktcnVuCmBgYAoKPiBgYGAKQnVpbGRpbmcgREFHIG9mIGpvYnMuLi4KTm90aGluZyB0byBiZSBkb25lIChhbGwgcmVxdWVzdGVkIGZpbGVzIGFyZSBwcmVzZW50IGFuZCB1cCB0byBkYXRlKS4KICBgYGAKCkFuZCB0aGF0IGFjdHVhbGx5IG1ha2VzIHNlbnNlOiBldmVuIHRob3VnaCB3ZSB1c2VkIHdpbGRjYXJkcywgdGhlIHJ1bGVzIGVuZGVkIHVwCndpdGggaWRlbnRpY2FsIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzLgoKV2UgY2FuIGV4dGVuZCB3aWxkY2FyZHMgYWNyb3NzIHJlbWFpbmluZyBydWxlcyBhcyBiZWxvdy4gTm90ZSB0aGF0IHdlIG5lZWQgdG8gCmtlZXAgdGhlIGxpdGVyYWwgdmFsdWUgaW4gdGhlICoqYWxsKiogcnVsZSBzbyB0aGUgb3RoZXIgcnVsZXMgY2FuIGRlcml2ZSB0aGUKdmFsdWUgb2YgdGhlIHdpbGRjYXJkLgoKYGBgCnJ1bGUgYWxsOgogICAgaW5wdXQ6ICJyZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc2VsZWN0X3dvcmRzLnR4dCIKCnJ1bGUgc2VsZWN0X3dvcmRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNvcnRfY291bnRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc2VsZWN0X3dvcmRzLnR4dCIKICAgIHNoZWxsOiAiZWdyZXAgJ14oSm98QW15fExhdXJpZXxCZXRoKVxzJyB7aW5wdXR9ID4ge291dHB1dH0iCgpydWxlIHNvcnRfY291bnRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LmNvdW50X3dvcmRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc29ydF9jb3VudHMudHh0IgogICAgc2hlbGw6ICIiIgoJc29ydCAtazEsMW5yIHtpbnB1dH0gXAoJICAgIHwgYXdrICdCRUdJTiB7e3ByaW50ICJ3b3JkXHRjb3VudCJ9fSB7eyBwcmludCAkMiAiXHQiICQxfX0nIFwKICAgICAgICAgICAgPiB7b3V0cHV0fQogICAgICAgICIiIgpydWxlIGNvdW50X3dvcmRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNwbGl0X3dvcmRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uY291bnRfd29yZHMudHh0IgogICAgc2hlbGw6ICJzb3J0IHtpbnB1dH0gfCB1bmlxIC1jID4ge291dHB1dH0iCgpydWxlIHNwbGl0X3dvcmRzOgogICAgaW5wdXQ6ICJpbnB1dHMve2Jhc2VfbmFtZX0udHh0IgogICAgb3V0cHV0OiAicmVzdWx0cy97YmFzZV9uYW1lfS5zcGxpdF93b3Jkcy50eHQiCiAgICBzaGVsbDogImNhdCB7aW5wdXR9IHwgdHIgLWNzICdbOmFscGhhOl0nICdcbicgPiB7b3V0cHV0fSIKYGBgCgpOb3cgdGhhdCB0aGUgU25ha2VmaWxlIGlzIHVzaW5nIHdpbGRjYXJkcywgaXQgaXMgdHJpdmlhbCB0byBleHRlbmQgaXQgdG8gbmV3IAppbnB1dHMuIFdlIGFkanVzdCB0aGUgKiphbGwqKiBydWxlIGFkZGluZyBhIHNlY29uZCB2YWx1ZSwgc2VwYXJhdGVkIGJ5IGEgY29tbWE6CgpgYGAKcnVsZSBhbGw6CiAgICBpbnB1dDogInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zZWxlY3Rfd29yZHMudHh0IiwgInJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMi5zZWxlY3Rfd29yZHMudHh0IgouLi4KYGBgCgpUaGUgYWRkaXRpb24gb2YgYSBuZXcgd2lsZGNhcmQgdmFsdWUgKGxpdHRsZV93b21lbl9wYXJ0XzIpIHdpbGwgdHJpZ2dlciBhbGwgZml2ZQpydWxlcy4KCmBgYHNoCnNuYWtlbWFrZSAtLWRyeS1ydW4KYGBgCgo+IGBgYAouLi4KSm9iIHN0YXRzOgpqb2IgICAgICAgICAgICAgY291bnQKLS0tLS0tLS0tLS0tICAtLS0tLS0tCmFsbCAgICAgICAgICAgICAgICAgMQpjb3VudF93b3JkcyAgICAgICAgIDEKc2VsZWN0X3dvcmRzICAgICAgICAxCnNvcnRfY291bnRzICAgICAgICAgMQpzcGxpdF93b3JkcyAgICAgICAgIDEKdG90YWwgICAgICAgICAgICAgICA1Ci4uLgogIGBgYAoKQmVmb3JlIHdlIHJ1biB0aGlzIGZvciByZWFsLCBsZXQncyBhZGQgYSBuZXcgZmxhZyBgLS1mb3JjZWFsbGAgdG8gdGVsbCBzbmFrZW1ha2UKdG8gdHJpZ2dlciBldmVyeSBzaW5nbGUgcnVsZSBmb3IgYWxsIHBvc3NpYmxlIGlucHV0cy4gQmFzaWNhbGx5IGFjdCBsaWtlIHRoZXJlIAphcmUgbm8gZXhpc3Rpbmcgb3V0cHV0cyBhbmQgaXQgbmVlZHMgdG8gc3RhcnQgZnJvbSBzY3JhdGNoLiBCdXQgdGhpcyBpcyBzdGlsbAphIGRyeS1ydW4sIHNvIG5vIGZpbGVzIHdpbGwgYmUgY2hhbmdlZC4KCmBgYHNoCnNuYWtlbWFrZSAtLWRyeS1ydW4gLS1mb3JjZWFsbApgYGAKCj4gYGBgCi4uLgpKb2Igc3RhdHM6CmpvYiAgICAgICAgICAgICBjb3VudAotLS0tLS0tLS0tLS0gIC0tLS0tLS0KYWxsICAgICAgICAgICAgICAgICAxCmNvdW50X3dvcmRzICAgICAgICAgMgpzZWxlY3Rfd29yZHMgICAgICAgIDIKc29ydF9jb3VudHMgICAgICAgICAyCnNwbGl0X3dvcmRzICAgICAgICAgMgp0b3RhbCAgICAgICAgICAgICAgIDkKLi4uCiAgYGBgCgpUcnkgZ2VuZXJhdGluZyBhIERBRyB2aXN1YWxpemF0aW9uLiAoTm93IGl0J3MgdHJ1bHkgbG9va2luZyBtb3JlIGxpa2UgYSAKZ3JhcGguKSBOb3RlOgoKLSBFYWNoIHdpbGRjYXJkIHZhbHVlIGdldHMgaXQncyBvd24gcGF0aAotIFRoZSB3aWxkY2FyZCB2YWx1ZXMgYXJlIGRpc3BsYXllZCBhdCB0aGUgaW5wdXQKLSBTb21lIGJveCBvdXRsaW5lcyBhcmUgc29saWQgYW5kIG90aGVyIGFyZSBkb3R0ZWQ7IHdoeSBpcyB0aGF0PwoKYGBgc2gKc25ha2VtYWtlIC0tZGFnIHwgZG90IC1HcmFua2Rpcj0iQlQiIC1UcG5nID4gZGFnX2ludmVydGVkX3dpbGRjYXJkcy5wbmcKYGBgCgohW2RhZ19pbnZlcnRlZF93aWxkY2FyZHMucG5nXShpbWFnZXMvTW9kdWxlMDdfZGFnX2ludmVydGVkX3dpbGRjYXJkcy5wbmcpCjxici8+CgpXaXRoIGNvbXBsZXggd29ya2Zsb3dzLCB5b3Ugc29tZXRpbWVzIGRvbid0IHdhbnQgdG8gc2VlIGFsbCB0aGUgcG9zc2libGUgaW5wdXRzIAphbmQgd291bGQgcmF0aGVyIGp1c3Qgc2VlIHRoZSBhYnN0cmFjdCByZWxhdGlvbnNoaXAgb2YgdGhlIHJ1bGVzLiBTbmFrZW1ha2UKc3VwcG9ydHMgdGhpcyB3aXRoIGEgcmVsYXRlZCBmbGFnIGAtLXJ1bGVncmFwaGAKCmBgYHNoCnNuYWtlbWFrZSAtLXJ1bGVncmFwaCB8IGRvdCAtR3JhbmtkaXI9IkJUIiAtVHBuZyA+IHJ1bGVncmFwaC5wbmcKYGBgCgohW3J1bGVncmFwaC5wbmddKGltYWdlcy9Nb2R1bGUwN19ydWxlZ3JhcGgucG5nKQo8YnIvPgoKCk9rLiBHbyBhaGVhZCBhbmQgcnVuIGBzbmFrZW1ha2VgIHVudGlsIHlvdSBhcmUgMTAwJSBjb21wbGV0ZSBhbmQgc2VlIHRoZXNlIGZpbGVzIGluIApyZXN1bHRzOgoKPiBgYGAKJCBscyByZXN1bHRzCmxpdHRsZV93b21lbl9wYXJ0XzEuY291bnRfd29yZHMudHh0ICAgbGl0dGxlX3dvbWVuX3BhcnRfMi5jb3VudF93b3Jkcy50eHQKbGl0dGxlX3dvbWVuX3BhcnRfMS5zZWxlY3Rfd29yZHMudHh0ICBsaXR0bGVfd29tZW5fcGFydF8yLnNlbGVjdF93b3Jkcy50eHQKbGl0dGxlX3dvbWVuX3BhcnRfMS5zb3J0X2NvdW50cy50eHQgICBsaXR0bGVfd29tZW5fcGFydF8yLnNvcnRfY291bnRzLnR4dApsaXR0bGVfd29tZW5fcGFydF8xLnNwbGl0X3dvcmRzLnR4dCAgIGxpdHRsZV93b21lbl9wYXJ0XzIuc3BsaXRfd29yZHMudHh0CiAgYGBgCgoKIyMjIFRoZSBleHBhbmQgZnVuY3Rpb24gLyBjb25maWcgZmlsZXMgLyBwYXJhbWV0ZXJzCgpJZGVhbGx5LCBhIHdvcmtmbG93IGNvdWxkIGJlIHJ1biBvbiBhIG5ldyBzZXQgb2YgaW5wdXRzIHdpdGhvdXQgY2hhbmdpbmcgdGhlClNuYWtlZmlsZSBhdCBhbGwuIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgdGV4dCBvZiBTaGFrZXNwZWFyZSdzIFtSb21lbyBhbmQKSnVsaWV0XShodHRwczovL3d3dy5ndXRlbmJlcmcub3JnL2Vib29rcy8xNTEzKSB3ZSBjb3VsZCBzZWUgd2hldGhlciBNb250YWd1ZSBpcwptZW50aW9uZWQgbW9yZSB0aGFuIENhcHVsZXQuIE1vc3Qgb2YgdGhlIHJ1bGVzIGluIHRoZSB3b3JrZmxvdyBhcmUgYWxyZWFkeSAKZ2VuZXJhbCBlbm91Z2ggdG8gd29yayB3aXRoIHR3byBleGNlcHRpb25zOgoKLSBUaGUgKiphbGwqKiBydWxlIG1lbnRpb25zIHNwZWNpZmljIHRleHRzLgotIFRoZSAqKnNlbGVjdF93b3JkcyoqIHJ1bGUgbWVudGlvbnMgc3BlY2lmaWMgbmFtZXMuCgpXZSBjYW4gZXh0cmFjdCB0aGVzZSBzcGVjaWZpY3MgZnJvbSB0aGUgU25ha2VmaWxlIHVzaW5nIGEgY29tcGFuaW9uIApjb25maWd1cmF0aW9uIGZpbGUuIFdlJ2xsIHN0YXJ0IHdpdGggdGhlICoqc2VsZWN0X3dvcmRzKiogcnVsZS4KCgpgYGAKcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc29ydF9jb3VudHMudHh0IgogICAgb3V0cHV0OiAicmVzdWx0cy97YmFzZV9uYW1lfS5zZWxlY3Rfd29yZHMudHh0IgogICAgc2hlbGw6ICJlZ3JlcCAnXihKb3xBbXl8TGF1cmllfEJldGgpXHMnIHtpbnB1dH0gPiB7b3V0cHV0fSIKYGBgCgpGaXJzdGx5LCB3ZSdsbCBwdWxsIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gb3V0IG9mIHRoZSBzaGVsbCBkaXJlY3RpdmUgaW50byBhCltjb25maWd1cmF0aW9uCmZpbGVdKGh0dHBzOi8vc25ha2VtYWtlLnJlYWR0aGVkb2NzLmlvL2VuL3N0YWJsZS9zbmFrZWZpbGVzL2NvbmZpZ3VyYXRpb24uaHRtbCNjb25maWd1cmF0aW9uKXt0YXJnZXQ9Il9ibGFuayJ9LgpTbmFrZW1ha2Ugc3VwcG9ydHMgc2V2ZXJhbCBzdHlsZXMgb2YgY29uZmlndXJhdGlvbiBmaWxlOyB3ZSdsbCB1c2UgdGhlIFlBTUwKc3ludGF4LiBCeSBjb252ZW50aW9uIHdlJ2xsIGNyZWF0ZSBjb25maWcvY29uZmlnLnlhbWw7IHlvdSBjb3VsZCBjcmVhdGUgYW5kIGVkaXQKdGhpcyBmaWxlIG1hbnVhbGx5OyBhbHRlcm5hdGl2ZWx5IHlvdSBjYW4gYWxzbyBleGVjdXRlIHRoZSBsaW5lIGJlbG93OgoKYGBgc2gKbWtkaXIgY29uZmlnCmVjaG8gJ3NlbGVjdF93b3Jkc19yZWdleDogXihKb3xBbXl8TGF1cmllfEJldGgpXHMnID4gY29uZmlnL2NvbmZpZy55YW1sCmNhdCBjb25maWcvY29uZmlnLnlhbWwKYGBgCgpOb3cgYWRkIHRoaXMgbGluZSBhYm92ZSB0aGUgKiphbGwqKjoKCmBgYApjb25maWdmaWxlOiAiY29uZmlnL2NvbmZpZy55YW1sIgpgYGAKCkFkZCBhIHBhcmFtZXRlciBpbml0aWFsaXplZCB0byB0aGUgY29uZmlnIGtleSAqc2VsZWN0X3dvcmRzX3JlZ2V4Ki4gVGhlbiBhZGp1c3QKdGhlIHNlbGVjdF93b3JkcyBydWxlIHRvIHJlZmVybmNlIHRoYXQgcGFyYW1ldGVyLgoKYGBgCnJ1bGUgc2VsZWN0X3dvcmRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNvcnRfY291bnRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc2VsZWN0X3dvcmRzLnR4dCIKICAgIHBhcmFtczogcmVnZXg9Y29uZmlnW3NlbGVjdF93b3Jkc19yZWdleF0KICAgIHNoZWxsOiAiZWdyZXAgJ3twYXJhbXMucmVnZXh9JyB7aW5wdXR9ID4ge291dHB1dH0iCmBgYAoKVGhlIFtwYXJhbXMKZGlyZWN0aXZlXShodHRwczovL3NuYWtlbWFrZS5yZWFkdGhlZG9jcy5pby9lbi9zdGFibGUvc25ha2VmaWxlcy9ydWxlcy5odG1sI25vbi1maWxlLXBhcmFtZXRlcnMtZm9yLXJ1bGVzKXt0YXJnZXQ9Il9ibGFuayJ9CmlzIGEgd2F5IG9mIGFkanVzdGluZyB0aGUgc2hlbGwgY29tbWFuZCB3aXRoIGEgdmFsdWUgdGhhdCBpc24ndCB0aWVkIHRvIHRoZQpmaWxlc3lzdGVtLiBBbHNvIG5vdGUgdGhhdCBwYXJhbXMgY2FuIGJlIG5hbWVkIChlLmcuIGB4PSJ2YWx1ZSJgKSBhbmQgcmVmZXJlbmNlZApieSBuYW1lIGluIHRoZSBzaGVsbCAoYHtwYXJhbXMueH1gKS4KCk5vdyB0aGF0IHdlJ3ZlIG1hZGUgdGhpcyBjaGFuZ2UsIGxldCdzIGRyeS1ydW4gc25ha2VtYWtlLiBOb3RlIHdlJ3JlIGFkZGluZyB0aGUKYC1wYCBmbGFnIHNvIHNuYWtlbWFrZSB3aWxsIHByaW50IG91dCB0aGUgYWN0dWFsIGNvbW1hbmRzIGl0IHdpbGwgZXhlY3V0ZToKCmBgYHNoCnNuYWtlbWFrZSAtLWRyeS1ydW4gLXAKYGBgCgpJbiB0aGUgb3V0cHV0LCBub3RlOgoKLSBJbiBKb2Igc3RhdHMsIHdlIHNlZSBzbmFrZW1ha2UgYmVsaWV2ZXMgd2UgbmVlZCB0byByZXJ1biAqKnNlbGVjdF93b3JkcyoqIGZvciBib3RoIGlucHV0cy4KLSBJbiB0aGUgcnVsZSBkZXRhaWxzLCB0aGUgcmVhc29uIHRoZSBydWxlIGlzIHRyaWdnZXJlZCBpcyB0aGF0IGNvZGUgYW5kIHBhcmFtcyBoYXZlIGNoYW5nZWQKLSBCZWNhdXNlIHdlIHVzZWQgYC1wYCwgeW91IGNhbiBzZWUgdGhlIGFjdHVhbCBlZ3JlcCBzdGF0ZW1lbnQgKHdoaWNoIGxvb2tzIGZpbmUpLgoKPiBgYGAKQnVpbGRpbmcgREFHIG9mIGpvYnMuLi4KSm9iIHN0YXRzOgpqb2IgICAgICAgICAgICAgY291bnQKLS0tLS0tLS0tLS0tICAtLS0tLS0tCmFsbCAgICAgICAgICAgICAgICAgMQpzZWxlY3Rfd29yZHMgICAgICAgIDIKdG90YWwgICAgICAgICAgICAgICAzCi4KW01vbiBKdW4gMTAgMjM6MDE6MjEgMjAyNF0KcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNvcnRfY291bnRzLnR4dAogICAgb3V0cHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzEuc2VsZWN0X3dvcmRzLnR4dAogICAgam9iaWQ6IDEKICAgIHJlYXNvbjogQ29kZSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGV4ZWN1dGlvbjsgUGFyYW1zIGhhdmUgY2hhbmdlZCBzaW5jZSBsYXN0IGV4ZWN1dGlvbgogICAgd2lsZGNhcmRzOiBiYXNlX25hbWU9bGl0dGxlX3dvbWVuX3BhcnRfMQogICAgcmVzb3VyY2VzOiB0bXBkaXI9L3RtcAouCmVncmVwICdeKEpvfEFteXxMYXVyaWV8QmV0aClccycgcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNvcnRfY291bnRzLnR4dCA+IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMS5zZWxlY3Rfd29yZHMudHh0Ci4KW01vbiBKdW4gMTAgMjM6MDE6MjEgMjAyNF0KcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8yLnNvcnRfY291bnRzLnR4dAogICAgb3V0cHV0OiByZXN1bHRzL2xpdHRsZV93b21lbl9wYXJ0XzIuc2VsZWN0X3dvcmRzLnR4dAogICAgam9iaWQ6IDUKICAgIHJlYXNvbjogQ29kZSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGV4ZWN1dGlvbjsgUGFyYW1zIGhhdmUgY2hhbmdlZCBzaW5jZSBsYXN0IGV4ZWN1dGlvbgogICAgd2lsZGNhcmRzOiBiYXNlX25hbWU9bGl0dGxlX3dvbWVuX3BhcnRfMgogICAgcmVzb3VyY2VzOiB0bXBkaXI9L3RtcAouCmVncmVwICdeKEpvfEFteXxMYXVyaWV8QmV0aClccycgcmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8yLnNvcnRfY291bnRzLnR4dCA+IHJlc3VsdHMvbGl0dGxlX3dvbWVuX3BhcnRfMi5zZWxlY3Rfd29yZHMudHh0Ci4uLgogIGBgYAogIApHbyBhaGVhZCBhbmQgcnVuIHNuYWtlbWFrZSB1bnRpbCAxMDAlIGRvbmUuCgpOb3cgd2UnbGwgcHVsbCB0aGUgZmlsZSBiYXNlIG5hbWVzIGZyb20gdGhlICoqYWxsKiogcnVsZSBpbnRvIHRoZSBjb25maWcgZmlsZToKCmBgYApzZWxlY3Rfd29yZHNfcmVnZXg6IF4oSm98QW15fExhdXJpZXxCZXRoKVxzCgppbnB1dF9iYXNlX2ZpbGVuYW1lczoKICAtIGxpdHRsZV93b21lbl9wYXJ0XzEKICAtIGxpdHRsZV93b21lbl9wYXJ0XzIKYGBgCgpUbyBnZXQgdGhlc2UgdmFsdWVzIGZyb20gY29uZmlnLnlhbWwgaW50byB0aGUKKiphbGwqKiBydWxlLCBJIG5lZWQgdG8gaW50cm9kdWNlIHRoZSBgZXhwYW5kYCBmdW5jdGlvbi4KW2V4cGFuZF0oaHR0cHM6Ly9zbmFrZW1ha2UucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3NuYWtlZmlsZXMvcnVsZXMuaHRtbCN0aGUtZXhwYW5kLWZ1bmN0aW9uKXt0YXJnZXQ9Il9ibGFuayJ9CmlzIGEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY29tZXMgd2l0aCBTbmFrZW1ha2UuIEl0J3MgZWFzaWVyIHRvIGV4cGxhaW4gaWYgd2UKc2hvdyBhIGZldyBleGFtcGxlcyBvZiBpbnB1dHMgYW5kIG91dHB1dHM6Cgo+IGBgYApleHBhbmQoIntkYXRhc2V0fS9hLnR4dCIsIGRhdGFzZXQ9WzEsIDJdKQpbJzEvYS50eHQnLCAnMi9hLnR4dCcsICczL2EudHh0J10KLgpleHBhbmQoInthfS57Yn0iLCBhPVsnZmlnMScsICdmaWcyJywgJ2ZpZzMnXSwgYj1bJ3BuZycsICdwZGYnXSkKWydmaWcxLnBuZycsICdmaWcxLnBkZicsICdmaWcyLnBuZycsICdmaWcyLnBkZicsICdmaWczLnBuZycsICdmaWczLnBkZiddCi4KZXhwYW5kKCJyZXN1bHRzL3t4fS5zZWxlY3Rfd29yZHMudHh0IiwgXAouLi4gICAgICAgICB4PVsibGl0dGxlX3dvbWVuX3BhcnRfMSIsICJsaXR0bGVfd29tZW5fcGFydF8yIl0pClsncmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8xLnNlbGVjdF93b3Jkcy50eHQnLCAncmVzdWx0cy9saXR0bGVfd29tZW5fcGFydF8yLnNlbGVjdF93b3Jkcy50eHQnXQogIGBgYAoKYGV4cGFuZGAgYWNjZXB0cyBhIHN0cmluZyBwYXR0ZXJuIHdpdGggbmFtZWQgcGxhY2Vob2xkZXJzIChlLmcuIHtkYXRhc2V0fSkgYW5kCm5hbWVkIGxpc3RzIChlLmcuIGRhdGFzZXQ9WzEsIDJdKTsgaXQgYnVpbGRzIGEgbGlzdCBvZiBzdHJpbmdzIGJ5IGluc2VydGluZyB0aGUKbGlzdCB2YWx1ZXMgaW50byB0aGUgcGF0dGVybi4KClRoYXQgbGFzdCBleGFtcGxlIGFib3ZlIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkIGluIHRoZSAqKmFsbCoqIHJ1bGUuIFRoZSBmaW5hbCAKc3RlcCBpcyB0byBhZGFwdCB0aGUgZXhhbXBsZSBhYm92ZSB0byB1c2UgdGhlIGNvbmZpZyBmaWxlLCBsaWtlIHNvOgoKYGBgCnJ1bGUgYWxsOgogICAgaW5wdXQ6IGV4cGFuZCgicmVzdWx0cy97eH0uc2VsZWN0X3dvcmRzLnR4dCIsIFwKICAgICAgICB4PWNvbmZpZ1snaW5wdXRfYmFzZV9maWxlbmFtZXMnXSkKYGBgCgpUaGUgU25ha2VmaWxlIGlzIG5vdyBmcmVlIG9mIGFueSByZWZlcmVuY2VzIHRvIHNwZWNpZmljIGlucHV0cy4gVGhlIHdvcmtmbG93CmNhbiBiZSBydW4gb24gYSBkaWZmZXJlbnQgc2V0IG9mIGlucHV0cyBieSB1c2luZyBhIG5ldyBjb25maWcueWFtbC4KCmBgYApjb25maWdmaWxlOiAiY29uZmlnL2NvbmZpZy55YW1sIgoKcnVsZSBhbGw6CiAgICBpbnB1dDogZXhwYW5kKCJyZXN1bHRzL3t4fS5zZWxlY3Rfd29yZHMudHh0IiwgXAogICAgeD1jb25maWdbJ2lucHV0X2Jhc2VfZmlsZW5hbWVzJ10pCgoKcnVsZSBzZWxlY3Rfd29yZHM6CiAgICBpbnB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc29ydF9jb3VudHMudHh0IgogICAgb3V0cHV0OiAicmVzdWx0cy97YmFzZV9uYW1lfS5zZWxlY3Rfd29yZHMudHh0IgogICAgcGFyYW1zOiByZWdleD1jb25maWdbInNlbGVjdF93b3Jkc19yZWdleCJdCiAgICBzaGVsbDogImVncmVwICd7cGFyYW1zLnJlZ2V4fScge2lucHV0fSA+IHtvdXRwdXR9IgoKcnVsZSBzb3J0X2NvdW50czoKICAgIGlucHV0OiAicmVzdWx0cy97YmFzZV9uYW1lfS5jb3VudF93b3Jkcy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNvcnRfY291bnRzLnR4dCIKICAgIHNoZWxsOiAiIiIKCXNvcnQgLWsxLDFuciB7aW5wdXR9IFwKCSAgICB8IGF3ayAnQkVHSU4ge3twcmludCAid29yZFx0Y291bnQifX0ge3sgcHJpbnQgJDIgIlx0IiAkMX19JyBcCiAgICAgICAgICAgID4ge291dHB1dH0KICAgICAgICAiIiIKcnVsZSBjb3VudF93b3JkczoKICAgIGlucHV0OiAicmVzdWx0cy97YmFzZV9uYW1lfS5zcGxpdF93b3Jkcy50eHQiCiAgICBvdXRwdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LmNvdW50X3dvcmRzLnR4dCIKICAgIHNoZWxsOiAic29ydCB7aW5wdXR9IHwgdW5pcSAtYyA+IHtvdXRwdXR9IgoKcnVsZSBzcGxpdF93b3JkczoKICAgIGlucHV0OiAiaW5wdXRzL3tiYXNlX25hbWV9LnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc3BsaXRfd29yZHMudHh0IgogICAgc2hlbGw6ICJjYXQge2lucHV0fSB8IHRyIC1jcyAnWzphbHBoYTpdJyAnXG4nID4ge291dHB1dH0iCgpgYGAKCi0tLQoKCiMjIyBTbmFrZW1ha2Ugb24gR3JlYXQgTGFrZXMKCgpBbGwgdGhpcyB0aW1lIHdlJ3ZlIGJlZW4gZXhlY3V0aW5nIHRoZSB3b3JrZmxvdyBvbiB0aGUgbG9naW4tbm9kZXMuIEl0J3MKZ2VuZXJhbGx5IGZpbmUgdG8gZXhlY3V0ZSB0aGUgYHNuYWtlbWFrZWAgcHJvY2VzcyBpdHNlbGYgb24gdGhlIGxvZ2luLW5vZGUsIGJ1dApmb3IgYSBtb3JlIGRlbWFuZGluZyB3b3JrZmxvdyB5b3Ugc2hvdWxkIGV4ZWN1dGUgdGhlIHJ1bGVzIG9uIEdyZWF0IExha2VzIHdvcmtlcgpub2Rlcy4KCkl0J3Mgc3RyYWlnaHRmb3J3YXJkIHRvIGRvIHRoaXMgYnkgdXNpbmcgYSBwcm9maWxlLiBBIHByb2ZpbGUgaXMgZXNzZW50aWFsbHkKanVzdCBhIGxpdHRsZSBjb25maWcgZmlsZSB0aGF0IHRlbGxzIGBzbmFrZW1ha2VgIGhvdyBpdCBzaG91bGQgc3VibWl0IHJ1bGVzIGFzCmpvYnMuIENoZWNrIG91dCBzbmFrZW1ha2UgZG9jcyBmb3IgZGV0YWlscyBvbgpbcHJvZmlsZV0oaHR0cHM6Ly9zbmFrZW1ha2UucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2V4ZWN1dGluZy9jbGkuaHRtbCNwcm9maWxlcyl7dGFyZ2V0PSJfYmxhbmsifQpvcHRpb25zLiBXZSdsbCBzdGFydCB3aXRoIGEgc2ltcGxlIHByb2ZpbGUgYnVpbHQgZm9yIEdyZWF0IExha2VzOgoKYGBgc2gKY3AgLXIgL25mcy90dXJiby91bW1zLWJpb2luZi13a3NocC93b3Jrc2hvcC9zaGFyZWQtZGF0YS9wcm9maWxlLyBjb25maWcvCmBgYAo8ZGl2IGNsYXNzPSJ3cmFwcGVyIj4KPHRhYmxlIGNsYXNzPSdmaWcnPjx0cj48dGggY2xhc3M9J2ZpZyc+Y29uZmlnL3Byb2ZpbGUvY29uZmlnLnlhbWw8L3RoPjwvdHI+Cjx0cj48dGQgY2xhc3M9J2ZpZyc+PHByZT4KcHJpbnRzaGVsbGNtZHM6IFRydWUKa2VlcC1nb2luZzogVHJ1ZQp1c2Utc2luZ3VsYXJpdHk6IFRydWUKc2luZ3VsYXJpdHktYXJnczogIi0tY2xlYW5lbnYgLUIgJChwd2QpIgpjbHVzdGVyOiBzYmF0Y2ggLS1qb2ItbmFtZT1hbGNvdHRfe3J1bGV9X3t3aWxkY2FyZHN9IC0tYWNjb3VudD1iaW9pbmZfd2tzaHBfY2xhc3MgLS1wYXJ0aXRpb249c3RhbmRhcmQgLS1ub2Rlcz0xIC0tY3B1cy1wZXItdGFzaz17cmVzb3VyY2VzLmNwdXN9IC0tbWVtPXtyZXNvdXJjZXMubWVtX21ifSAtLXRpbWU9e3Jlc291cmNlcy50aW1lX21pbn0gLS1vdXRwdXQ9Y2x1c3Rlcl9sb2dzLyV4LSVqLmxvZyAtLXBhcnNhYmxlCmRlZmF1bHQtcmVzb3VyY2VzOiBbY3B1cz0xLCBtZW1fbWI9MjAwMCwgdGltZV9taW49MTIwXQpyZXJ1bi10cmlnZ2VyczogW210aW1lXQpsYXRlbmN5LXdhaXQ6IDMwMApqb2JzOiA1CjwvcHJlPjwvdGQ+PC90cj48L3RhYmxlPgo8L2Rpdj4KCkludm9raW5nIGBzbmFrZW1ha2VgIHdpdGggdGhpcyBwcm9maWxlIHN1Ym1pdHMgZWFjaCBydWxlIGEgYW4gc2JhdGNoIGpvYjoKCmBgYHNoCiMgY2xlYXIgb3V0IGV4aXN0aW5nIGZpbGVzIHNvIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIGRvCnJtIHJlc3VsdHMvKgoKc25ha2VtYWtlIC0tcHJvZmlsZSBjb25maWcvcHJvZmlsZQpgYGAKCk5vdGUgdGhhdCB5b3UgY2FuIGFkanVzdCB0aGUgU0xVUk0gam9iIGdlb21ldHJ5IGJ5IGFkZGluZyBhICpyZXNvdXJjZXMqIGRpcmVjdGl2ZQp0byBhIHJ1bGUuIFRoZXNlIHZhbHVlcyB3aWxsIGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBzYmF0Y2ggcmVxdWVzdCBmb3IgdGhpcwpydWxlLgoKYGBgCnJ1bGUgc2VsZWN0X3dvcmRzOgogICAgaW5wdXQ6ICJyZXN1bHRzL3tiYXNlX25hbWV9LnNvcnRfY291bnRzLnR4dCIKICAgIG91dHB1dDogInJlc3VsdHMve2Jhc2VfbmFtZX0uc2VsZWN0X3dvcmRzLnR4dCIKICAgIHJlc291cmNlczogY3B1cz00LCBtZW1fbWI9NDAwMCwgdGltZV9taW49NSAgCiAgICBwYXJhbXM6IHJlZ2V4PWNvbmZpZ1sic2VsZWN0X3dvcmRzX3JlZ2V4Il0KICAgIHNoZWxsOiAiZWdyZXAgJ3twYXJhbXMucmVnZXh9JyB7aW5wdXR9ID4ge291dHB1dH0iCmBgYAoKIyMjIFVzaW5nIHRtdXgKClt0bXV4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UbXV4KSBpcyBhIHVuaXggdXRpbGl0eSB0aGF0IGxldCdzIHlvdSAKY3JlYXRlIHZpcnR1YWwgc2NyZWVucyBpbnNpZGUgb2YgYSBzaW5nbGUgc2Vzc2lvbi4gKEl0J3MgbGlrZSB0aGUgVW5peCB1dGlsaXR5IAoqc2NyZWVuKiwgYnV0IG1vcmUgcG93ZXJmdWwgYW5kIGN1cnJlbnQuKSBGb3Igb3VyIHB1cnBvc2VzLCB0aGUga2lsbGVyIGZlYXR1cmUgCm9mIHRtdXggaXMgY2FwdHVyZWQgaW4gdGhpcyBzaW1wbGUgdmlnbmV0dGU6CgotIGxvZ2luIHRvIGdyZWF0IGxha2VzIGFuZCBzdGFydCBhIHRtdXggc2Vzc2lvbiBvbiB0aGUgbG9naW4tbm9kZTogYHRtdXhgCi0gc3RhcnQgYSBsb25nIHJ1bm5pbmcgdGFzayAoZS5nLiBhIHNuYWtlbWFrZSB3b3JrZmxvdyB3aGljaCBzdWJtaXRzIHRvIHRoZSBjbHVzdGVyKQotIGRldGFjaCBmcm9tIHRoYXQgdG11eCBzZXNzaW9uOiBoaXQgYGN0cmwtYmAgYGRgCi0gdHVybiBvZmYgeW91ciBjb21wdXRlciwgZ28gaG9tZSwgYW5kIGxvZ2luIHRvIGdyZWF0IGxha2VzIGZyb20gZGlmZmVyZW50IGNvbXB1dGVyCi0gcmVhdHRhY2ggdG8gdGhhdCB0bXV4IHNlc3Npb246IGB0bXV4IGF0dGFjaGAKLSB5b3Ugd2lsbCBzZWUgeW91ciBsb25nLXJ1bm5pbmcgdGFzayBoYXMgYmVlbiBydW5uaW5nIGFsbCBhbG9uZywgY29tcGxldGVseSB1bmFmZmVjdGVkIGJ5IHlvdXIgd2FuZGVyaW5ncwoKQW5kIGluIGZhY3QsIHRtdXggY2FuIGFjdHVhbGx5IGRvIG11Y2gsIG11Y2ggbW9yZS4gSGVyZSdzIGEgbmlmdHkgW2NoZWF0c2hlZXRdKGh0dHBzOi8vb3BlbnNvdXJjZS5jb20vc2l0ZXMvZGVmYXVsdC9maWxlcy9nYXRlZC1jb250ZW50L29zZGNfY2hlYXRzaGVldC10bXV4LTIwMjEuNi4yNS5wZGYpe3RhcmdldD0iX2JsYW5rIn0uCgotLS0KCiMjIFBybyB0aXBzCgoxLiBTdGFydCBsZWFybmluZyBTbmFrZW1ha2Ugd2l0aCBhIHNpbXBsZSB3b3JrZmxvdy4gRG9uJ3Qgc3RhcnQgd2l0aCBhIHJlYWxseQogICBjb21wbGV4IHdvcmtmbG93LgoyLiBJdCdzIG9rIHRvIGJ1aWxkIHlvdXIgU25ha2VmaWxlIGZyb20gdGhlIGZpcnN0IHN0ZXBzIHRvd2FyZCB0aGUgbGFzdCwKICAgYnV0IHJlbWVtYmVyIHRoYXQgU25ha2VtYWtlICJ0aGlua3MiIGZyb20gdGhlIGxhc3Qgb3V0cHV0IGJhY2t3YXJkLgozLiBLZWVwIHlvdXIgaW5wdXRzLCBvdXRwdXRzLCBhbmQgd29ya2Zsb3cgaW4gc2VwYXJhdGUgZGlyZWN0b3JpZXMuCjQuIEJ1aWxkIHlvdXIgU25ha2VmaWxlIGluY3JlbWVudGFsbHkuCiAgIGEpIFN0YXJ0IHdpdGggYSBzaW5nbGUgaW5wdXQuCiAgIGIpIEFkZCBhIHJ1bGUgYXQgYSB0aW1lLgogICBjKSBNYWtlIHNtYWxsIGNoYW5nZXMgYW5kICB1c2UgYGRyeS1ydW5gIGxpYmVyYWxseS4KICAgZCkgT0sgdG8gc3RhcnQgYnkgaGFyZGNvZGluZyBmaWxlbmFtZXM7IHB1dCB0aGUgd2lsZGNhcmRzIGluIGFmdGVyd2FyZC4KNS4gS2VlcCBjb25zaXN0ZW50IG5hbWluZyBjb252ZW50aW9ucy4gSW5jbHVkaW5nIHlvdXIgcnVsZSBuYW1lcyBpbiB5b3VyIGZpbGUKICAgbmFtZXMgd2lsbCBoZWxwIHlvdSB0cm91Ymxlc2hvb3QuIFNvbWUgcGVvcGxlIGluY2x1ZGUgbnVtYmVycyBpbiB0aGUgZmlsZQogICBuYW1lcyBvciBwbGFjZSBkaWZmZXJlbnQgb3V0cHV0cyBpbiBkaWZmZXJlbnQgZGlyZWN0b3JpZXMuIENob29zZSBhIHBhdHRlcm4KICAgdGhhdCB3b3JrcyBmb3IgeW91IGFuZCBiZSBjb25zaXN0ZW50Lgo2LiBJZiB5b3Ugc3Vic2V0IHlvdXIgaW5wdXQgZGF0YSBzbyB0aGF0IHlvdXIgc3RlcHMgYXJlIGZhc3QgYW5kIGxpZ2h0LCB5b3UgCiAgIGNhbiBwcm90b3R5cGUgdGhlIFNuYWtlZmlsZSBvbiB0aGUgbG9naW4tbm9kZXMuIChCdXQgYmUgcmVhZHkgdG8gaGl0IGNvbnRyb2wtQwogICBpZiB5b3Ugd2FuZGVyIGludG8gYSBjb21wdXRhdGlvbmFsbHkgaW50ZW5zaXZlIHN0ZXAuKQo3LiBVc2Ugc3BhY2VzIG5vdCB0YWJzLgo4LiBVc2UgY29uZmlnIGZpbGVzIHRvIGF2b2lkIGhhcmRjb2RpbmcgcGF0aHMgb3IgIm1hZ2ljIHZhbHVlcyIgaW4gdGhlIFNuYWtlZmlsZS4KCi0tLQoKIyMgS2V5IGlkZWFzCgoqIEEgcm9idXN0IHdvcmtmbG93IGF1dG9tYXRpb24gc29sdXRpb24gaXMgZ3JlYXQgYmVjYXVzZToKICAqIGl0IHN1cHBvcnRzIHNpbXBsZSAoZS5nLiBsaW5lYXIpIGFuZCBjb21wbGV4IChlLmcuIGdyYXBoKQogICAgdHJhbnNmb3JtYXRpb25zIGVxdWFsbHkgd2VsbAogICogb25seSBvdXRzdGFuZGluZyBzdGVwcyBhcmUgcnVuIGFuZCBpbmRpdmlkdWFsIHN0ZXBzIGFyZSBhdG9taWMKICAqIGl0J3MgZGVzaWduZWQgd2l0aCBzb2Z0d2FyZSBkZXBlbmRlbmN5IG1hbmFnZW1lbnQgaW4gbWluZAogICogaXQncyBlYXN5IHRvIHR1bmUsIHJlc3VsdGluZyBpbiBoaWdoZXIgcmVzb3VyY2UgZWZmaWNpZW5jeQogICogaXQncyBwb3J0YWJsZSBhY3Jvc3MgZXhlY3V0aW9uIGVudmlyb25tZW50cwogICogaXQncyBkZXNpZ25lZCB0byBncmFjZWZ1bGx5IHNjYWxlIHRvIG1hbnkgaW5wdXRzCiAgKiBhbGwgdGhlIGNhcGFiaWxpdGllcyBhYm92ZSBkb24ndCBvYnNjdXJlIHRoZSBhY3R1YWwgZGF0YSB0cmFuc2Zyb21hdGlvbgoqIFNuYWtlbWFrZSBpcyBhIFB5dGhvbiBwcm9ncmFtIHRoYXQgZXZhbHVhdGVzIHRoZSBydWxlcyBpbiBhIFNuYWtlZmlsZSBhZ2FpbnN0CiAgdGhlIGZpbGUgc3lzdGVtIGFuZCBhcHBsaWVzIHJ1bGVzIGFzIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHRoZSBkZXNpcmVkIG91dHB1dCAKICBmaWxlcy4KKiBUaGUgU25ha2VmaWxlIGlzIGEgc2ltcGxlIG1hcmtkb3duIGZpbGUgY29tcG9zZWQgb2YgcnVsZXMuIEVhY2ggcnVsZSBjb250YWlucwogICoqZGlyZWN0aXZlcyoqIHRoYXQgc3BlY2lmeSBpbnB1dHMsIG91dHB1dHMsIGNvbW1hbmRzIHRvIHJ1biBmb2UgdGhhdCBydWxlLgoqIFNuYWtlbWFrZSBidWlsZHMgdGhlIGludGVuZGVkIHNldCBvZiBydWxlcyBpbnRvIGEgKipkaXJlY3RlZCBhY3ljbGljIGdyYXBoKiogCiAgKERBRykuCiogVGhlICoqZHJ5LXJ1bioqIGVuYWJsZXMgeW91IHRvIHNlZSB0aGUgcnVsZXMgaXQgd2lsbCBleGVjdXRlIGluIGFkdmFuY2UuCiogWW91IGNhbiB2aXN1YWxpemUgdGhlIFNuYWtlbWFrZSBEQUcgb3IgcnVsZWdyYXBoIHVzaW5nIGBkb3RgLgoqIENvbW1hbmQgbGluZSBmbGFncyB3ZSByZXZpZXdlZDoKICAqIC1jCiAgKiAtbiAtLWRyeS1ydW4KICAqIC0tZGFnIC0tcnVsZWdyYXBoCiAgKiAtLWZvcmNlYWxsCiAgKiAtcCAtLXByaW50c2hlbGxjbWRzCgpSZWZlcmVuY2VzIGFuZCBsaW5rczoKLSBodHRwczovL3NuYWtlbWFrZS5yZWFkdGhlZG9jcy5pby9lbi9zdGFibGUvaW5kZXguaHRtbAogIC0gaHR0cHM6Ly9zbmFrZW1ha2UucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2V4ZWN1dGluZy9jbGkuaHRtbCNhbGwtb3B0aW9ucwogIC0gaHR0cHM6Ly9zbmFrZW1ha2UucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3NuYWtlZmlsZXMvd3JpdGluZ19zbmFrZWZpbGVzLmh0bWwjZ3JhbW1hcgoKRXhlcmNpc2UgMUE6CmNkIHRvIHRoZSBwcm9qZWN0IHB1YmxpY2F0aW9uX3NuYWtlbWFrZV8xCkdpdmVuIHRoaXMgREFHIGNhbiB5b3UgZmlsbCBpbiB0aGUgbWlzc2luZyBwYXJ0cyBvZiB0aGlzIFNuYWtlZmlsZT8KCgpFeGVyY2lzZSAxQjoKVXNlIHBhcmFtcyBhbmQgYSBjb25maWcgZmlsZSB0byBleHRyYWN0IGhhcmRjb2RlZCBpbnB1dHMgYW5kICJtYWdpYyB2YWx1ZXMiLgoKLS0tCgp8IFtQcmV2aW91cyBsZXNzb25dKE1vZHVsZTA2LWludHJvLXRvLXdvcmtmbG93LWF1dG9tYXRpb24uaHRtbCkgfCBbVG9wIG9mIHRoaXMgbGVzc29uXSgjdG9wKSB8IFtXcmFwIHVwXShNb2R1bGU5OV9XcmFwX3VwLmh0bWwpIHwKfCA6LS0tIHwgOi0tLS06IHwgLS0tOiB8Cg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Module07-intro-to-snakemake.md");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
